Args: mlir-opt --convert-func-to-llvm ../example/from_cg/playground.mlir -debug 
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubElementTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemRefLayoutAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubElementAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ElementsAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineBinaryOpExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineConstantExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineDimExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineMapStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::IntegerSetStorage)
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DebugActionManager::GenericHandler)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneRegion<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroSuccessors<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoRegionArguments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlock<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OpInvariants<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AffineScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsIsolatedFromAbove<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SymbolTable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasOnlyGraphRegion<Empty>)
Load new dialect in Context func
Load new dialect in Context cf
Load new dialect in Context arith
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectInlinerInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferizableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AutomaticAllocationScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface::Trait<Empty>)
Load new dialect in Context memref
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CopyOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ViewLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OffsetSizeAndStrideOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroRegions<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneResult<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NOperands<2>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ViewLikeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::MemRefsNormalizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ReturnLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AttrSizedOperandSegments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneOperand<Empty>)
Load new dialect in Context llvm
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMVoidType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMPPCFP128Type)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMX86MMXType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMTokenType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMLabelType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMMetadataType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMFunctionType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMPointerType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMFixedVectorType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMScalableVectorType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMArrayType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMStructType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::FastmathFlagsInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutAnalysis)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutOpInterface)

//===-------------------------------------------===//
Legalizing operation : 'builtin.module'(0x7fa290c07650) {
  * Fold {
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectFoldInterface)
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.func'(0x7fa290a063e0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.func -> ()' {
Trying to match "(anonymous namespace)::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x7fa290815c90)
    ** Erase   : 'func.func'(0x7fa290a063e0)
"(anonymous namespace)::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x7fa290815c90) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: builtin.module
'func.return' op expects parent op 'func.func'
'func.func' op symbol declaration cannot have public visibility
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"builtin.module"() ({
  "llvm.func"() ({
  ^bb0(%arg0: !llvm.ptr<i32>, %arg1: !llvm.ptr<i32>, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i64, %arg7: !llvm.ptr<i32>, %arg8: !llvm.ptr<i32>, %arg9: i64, %arg10: i64, %arg11: i64):
    %0 = "builtin.unrealized_conversion_cast"(%arg0, %arg1, %arg2, %arg3, %arg4, %arg5, %arg6) : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %1 = "builtin.unrealized_conversion_cast"(%arg7, %arg8, %arg9, %arg10, %arg11) : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %2 = "memref.reshape"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
    "func.return"(%2) : (memref<6xi32>) -> ()
  }) {function_type = !llvm.func<struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)> (ptr<i32>, ptr<i32>, i64, i64, i64, i64, i64, ptr<i32>, ptr<i32>, i64, i64, i64)>, linkage = #llvm.linkage<external>, sym_name = "memref_reshape"} : () -> ()
  "func.func"() ({
  }) {function_type = (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>, sym_name = "memref_reshape"} : () -> ()
  "func.func"() ({
    %0 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<2x3xi32>
    %1 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xi32>
    %2 = "func.call"(%0, %1) {callee = @memref_reshape} : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
    "memref.dealloc"(%2) : (memref<6xi32>) -> ()
    "func.return"() : () -> ()
  }) {function_type = () -> (), sym_name = "main"} : () -> ()
}) : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.reshape'(0x7fa290a05fd0) {
  %2 = "memref.reshape"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.return'(0x7fa290a06240) {
  "func.return"(%2) : (memref<6xi32>) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.return -> ()' {
Trying to match "(anonymous namespace)::ReturnOpLowering"
    ** Insert  : 'llvm.return'(0x7fa28ff087c0)
    ** Replace : 'func.return'(0x7fa290a06240)
"(anonymous namespace)::ReturnOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.return'(0x7fa28ff087c0) {
      "llvm.return"(%3) : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'llvm.return' op must be the last operation in the parent block
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: !llvm.ptr<i32>, %arg1: !llvm.ptr<i32>, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i64, %arg7: !llvm.ptr<i32>, %arg8: !llvm.ptr<i32>, %arg9: i64, %arg10: i64, %arg11: i64):
  %0 = "builtin.unrealized_conversion_cast"(%arg0, %arg1, %arg2, %arg3, %arg4, %arg5, %arg6) : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
  %1 = "builtin.unrealized_conversion_cast"(%arg7, %arg8, %arg9, %arg10, %arg11) : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
  %2 = "memref.reshape"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
  %3 = "builtin.unrealized_conversion_cast"(%2) : (memref<6xi32>) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
  "llvm.return"(%3) : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> ()
  "func.return"(%2) : (memref<6xi32>) -> ()
}) {function_type = !llvm.func<struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)> (ptr<i32>, ptr<i32>, i64, i64, i64, i64, i64, ptr<i32>, ptr<i32>, i64, i64, i64)>, linkage = #llvm.linkage<external>, sym_name = "memref_reshape"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.func'(0x7fa290c075f0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.func -> ()' {
Trying to match "(anonymous namespace)::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x7fa290913eb0)
    ** Erase   : 'func.func'(0x7fa290c075f0)
"(anonymous namespace)::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x7fa290913eb0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: builtin.module
'llvm.return' op must be the last operation in the parent block
'func.func' op symbol declaration cannot have public visibility
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"builtin.module"() ({
  "llvm.func"() ({
  ^bb0(%arg0: !llvm.ptr<i32>, %arg1: !llvm.ptr<i32>, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i64, %arg7: !llvm.ptr<i32>, %arg8: !llvm.ptr<i32>, %arg9: i64, %arg10: i64, %arg11: i64):
    %0 = "builtin.unrealized_conversion_cast"(%arg0, %arg1, %arg2, %arg3, %arg4, %arg5, %arg6) : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %1 = "builtin.unrealized_conversion_cast"(%arg7, %arg8, %arg9, %arg10, %arg11) : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %2 = "memref.reshape"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
    %3 = "builtin.unrealized_conversion_cast"(%2) : (memref<6xi32>) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    "llvm.return"(%3) : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> ()
    "func.return"(%2) : (memref<6xi32>) -> ()
  }) {function_type = !llvm.func<struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)> (ptr<i32>, ptr<i32>, i64, i64, i64, i64, i64, ptr<i32>, ptr<i32>, i64, i64, i64)>, linkage = #llvm.linkage<external>, sym_name = "memref_reshape"} : () -> ()
  "func.func"() ({
  }) {function_type = (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>, sym_name = "memref_reshape"} : () -> ()
  "llvm.func"() ({
    %0 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<2x3xi32>
    %1 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xi32>
    %2 = "func.call"(%0, %1) {callee = @memref_reshape} : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
    "memref.dealloc"(%2) : (memref<6xi32>) -> ()
    "func.return"() : () -> ()
  }) {function_type = !llvm.func<void ()>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()
  "func.func"() ({
  }) {function_type = () -> (), sym_name = "main"} : () -> ()
}) : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.alloc'(0x7fa290a06d40) {
  %0 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<2x3xi32>

  * Fold {
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ConstantLike<Empty>)
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.alloc'(0x7fa290a06e70) {
  %1 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xi32>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.call'(0x7fa290813c30) {
  %2 = "func.call"(%0, %1) {callee = @memref_reshape} : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.call -> ()' {
Trying to match "(anonymous namespace)::CallOpLowering"
    ** Insert  : 'llvm.extractvalue'(0x7fa290c0a6c0)
    ** Insert  : 'llvm.extractvalue'(0x7fa290c0a9a0)
    ** Insert  : 'llvm.extractvalue'(0x7fa290c0adb0)
    ** Insert  : 'llvm.extractvalue'(0x7fa290c0af60)
    ** Insert  : 'llvm.extractvalue'(0x7fa290c0b050)
    ** Insert  : 'llvm.extractvalue'(0x7fa290c0b200)
    ** Insert  : 'llvm.extractvalue'(0x7fa290c0b280)
    ** Insert  : 'llvm.extractvalue'(0x7fa290c0b3a0)
    ** Insert  : 'llvm.extractvalue'(0x7fa290c0b420)
    ** Insert  : 'llvm.extractvalue'(0x7fa290c0b4a0)
    ** Insert  : 'llvm.extractvalue'(0x7fa290c0b520)
    ** Insert  : 'llvm.extractvalue'(0x7fa290c0b6a0)
    ** Insert  : 'llvm.call'(0x7fa290c0b780)
    ** Replace : 'func.call'(0x7fa290813c30)
"(anonymous namespace)::CallOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fa290c0a6c0) {
      %4 = "llvm.extractvalue"(%1) {position = [0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> !llvm.ptr<i32>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fa290c0a9a0) {
      %5 = "llvm.extractvalue"(%1) {position = [1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> !llvm.ptr<i32>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fa290c0adb0) {
      %6 = "llvm.extractvalue"(%1) {position = [2]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fa290c0af60) {
      %7 = "llvm.extractvalue"(%1) {position = [3, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fa290c0b050) {
      %8 = "llvm.extractvalue"(%1) {position = [3, 1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fa290c0b200) {
      %9 = "llvm.extractvalue"(%1) {position = [4, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fa290c0b280) {
      %10 = "llvm.extractvalue"(%1) {position = [4, 1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fa290c0b3a0) {
      %11 = "llvm.extractvalue"(%3) {position = [0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> !llvm.ptr<i32>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fa290c0b420) {
      %12 = "llvm.extractvalue"(%3) {position = [1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> !llvm.ptr<i32>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fa290c0b4a0) {
      %13 = "llvm.extractvalue"(%3) {position = [2]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fa290c0b520) {
      %14 = "llvm.extractvalue"(%3) {position = [3, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fa290c0b6a0) {
      %15 = "llvm.extractvalue"(%3) {position = [4, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.call'(0x7fa290c0b780) {
      %16 = "llvm.call"(%4, %5, %6, %7, %8, %9, %10, %11, %12, %13, %14, %15) {callee = @memref_reshape} : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64, i64, i64, !llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::FastmathFlagsInterface::Trait<Empty>)
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
  %0 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<2x3xi32>
  %1 = "builtin.unrealized_conversion_cast"(%0) : (memref<2x3xi32>) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
  %2 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xi32>
  %3 = "builtin.unrealized_conversion_cast"(%2) : (memref<1xi32>) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
  %4 = "llvm.extractvalue"(%1) {position = [0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> !llvm.ptr<i32>
  %5 = "llvm.extractvalue"(%1) {position = [1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> !llvm.ptr<i32>
  %6 = "llvm.extractvalue"(%1) {position = [2]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %7 = "llvm.extractvalue"(%1) {position = [3, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %8 = "llvm.extractvalue"(%1) {position = [3, 1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %9 = "llvm.extractvalue"(%1) {position = [4, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %10 = "llvm.extractvalue"(%1) {position = [4, 1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %11 = "llvm.extractvalue"(%3) {position = [0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> !llvm.ptr<i32>
  %12 = "llvm.extractvalue"(%3) {position = [1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> !llvm.ptr<i32>
  %13 = "llvm.extractvalue"(%3) {position = [2]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64
  %14 = "llvm.extractvalue"(%3) {position = [3, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64
  %15 = "llvm.extractvalue"(%3) {position = [4, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64
  %16 = "llvm.call"(%4, %5, %6, %7, %8, %9, %10, %11, %12, %13, %14, %15) {callee = @memref_reshape} : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64, i64, i64, !llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
  %17 = "func.call"(%0, %2) {callee = @memref_reshape} : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
  "memref.dealloc"(%17) : (memref<6xi32>) -> ()
  "func.return"() : () -> ()
}) {function_type = !llvm.func<void ()>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.dealloc'(0x7fa290c073b0) {
  "memref.dealloc"(%17) : (memref<6xi32>) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.return'(0x7fa290c075a0) {
  "func.return"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.return -> ()' {
Trying to match "(anonymous namespace)::ReturnOpLowering"
    ** Insert  : 'llvm.return'(0x7fa290913c00)
    ** Replace : 'func.return'(0x7fa290c075a0)
"(anonymous namespace)::ReturnOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.return'(0x7fa290913c00) {
      "llvm.return"() : () -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'llvm.return' op must be the last operation in the parent block
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
  %0 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<2x3xi32>
  %1 = "builtin.unrealized_conversion_cast"(%0) : (memref<2x3xi32>) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
  %2 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xi32>
  %3 = "builtin.unrealized_conversion_cast"(%2) : (memref<1xi32>) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
  %4 = "llvm.extractvalue"(%1) {position = [0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> !llvm.ptr<i32>
  %5 = "llvm.extractvalue"(%1) {position = [1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> !llvm.ptr<i32>
  %6 = "llvm.extractvalue"(%1) {position = [2]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %7 = "llvm.extractvalue"(%1) {position = [3, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %8 = "llvm.extractvalue"(%1) {position = [3, 1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %9 = "llvm.extractvalue"(%1) {position = [4, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %10 = "llvm.extractvalue"(%1) {position = [4, 1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %11 = "llvm.extractvalue"(%3) {position = [0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> !llvm.ptr<i32>
  %12 = "llvm.extractvalue"(%3) {position = [1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> !llvm.ptr<i32>
  %13 = "llvm.extractvalue"(%3) {position = [2]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64
  %14 = "llvm.extractvalue"(%3) {position = [3, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64
  %15 = "llvm.extractvalue"(%3) {position = [4, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64
  %16 = "llvm.call"(%4, %5, %6, %7, %8, %9, %10, %11, %12, %13, %14, %15) {callee = @memref_reshape} : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64, i64, i64, !llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
  %17 = "func.call"(%0, %2) {callee = @memref_reshape} : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
  "memref.dealloc"(%17) : (memref<6xi32>) -> ()
  "llvm.return"() : () -> ()
  "func.return"() : () -> ()
}) {function_type = !llvm.func<void ()>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//
** Insert  : 'builtin.unrealized_conversion_cast'(0x7fa290814170)
** Insert  : 'builtin.unrealized_conversion_cast'(0x7fa290816060)
** Insert  : 'builtin.unrealized_conversion_cast'(0x7fa2908160e0)
** Insert  : 'llvm.mlir.undef'(0x7fa290b23f90)
** Insert  : 'llvm.insertvalue'(0x7fa290914870)
** Insert  : 'llvm.insertvalue'(0x7fa290914910)
** Insert  : 'llvm.insertvalue'(0x7fa2909149b0)
** Insert  : 'llvm.insertvalue'(0x7fa290914a50)
** Insert  : 'llvm.insertvalue'(0x7fa290914af0)
** Insert  : 'llvm.mlir.undef'(0x7fa290b24340)
** Insert  : 'llvm.insertvalue'(0x7fa290b24390)
** Insert  : 'llvm.insertvalue'(0x7fa290b24ef0)
** Insert  : 'llvm.insertvalue'(0x7fa290b24f90)
** Insert  : 'llvm.insertvalue'(0x7fa290b25030)
** Insert  : 'llvm.insertvalue'(0x7fa290b25150)
** Insert  : 'llvm.insertvalue'(0x7fa290b251f0)
** Insert  : 'llvm.insertvalue'(0x7fa290b25290)
** Insert  : 'builtin.unrealized_conversion_cast'(0x7fa290b250d0)
** Insert  : 'builtin.unrealized_conversion_cast'(0x7fa290b24930)
** Insert  : 'builtin.unrealized_conversion_cast'(0x7fa290b249b0)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::PreservedAnalyses::AllAnalysesType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutSpecInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface::Trait<Empty>)
mlir-asm-printer: Verifying operation: builtin.module
module attributes {llvm.data_layout = ""} {
  llvm.func @memref_reshape(%arg0: !llvm.ptr<i32>, %arg1: !llvm.ptr<i32>, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i64, %arg7: !llvm.ptr<i32>, %arg8: !llvm.ptr<i32>, %arg9: i64, %arg10: i64, %arg11: i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)> {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %5 = llvm.insertvalue %arg5, %4[4, 0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %6 = llvm.insertvalue %arg4, %5[3, 1] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %7 = llvm.insertvalue %arg6, %6[4, 1] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %8 = builtin.unrealized_conversion_cast %7 : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)> to memref<2x3xi32>
    %9 = llvm.mlir.undef : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %10 = llvm.insertvalue %arg7, %9[0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %11 = llvm.insertvalue %arg8, %10[1] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %12 = llvm.insertvalue %arg9, %11[2] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %arg10, %12[3, 0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %14 = llvm.insertvalue %arg11, %13[4, 0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %15 = builtin.unrealized_conversion_cast %14 : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)> to memref<1xi32>
    %16 = memref.reshape %8(%15) : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
    %17 = builtin.unrealized_conversion_cast %16 : memref<6xi32> to !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    llvm.return %17 : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
  }
  llvm.func @main() {
    %0 = memref.alloc() : memref<2x3xi32>
    %1 = builtin.unrealized_conversion_cast %0 : memref<2x3xi32> to !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %2 = memref.alloc() : memref<1xi32>
    %3 = builtin.unrealized_conversion_cast %2 : memref<1xi32> to !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %4 = llvm.extractvalue %1[0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %5 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %6 = llvm.extractvalue %1[2] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %7 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %8 = llvm.extractvalue %1[3, 1] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %9 = llvm.extractvalue %1[4, 0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %10 = llvm.extractvalue %1[4, 1] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %11 = llvm.extractvalue %3[0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %12 = llvm.extractvalue %3[1] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.extractvalue %3[2] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %14 = llvm.extractvalue %3[3, 0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %15 = llvm.extractvalue %3[4, 0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %16 = llvm.call @memref_reshape(%4, %5, %6, %7, %8, %9, %10, %11, %12, %13, %14, %15) : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64, i64, i64, !llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %17 = builtin.unrealized_conversion_cast %16 : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)> to memref<6xi32>
    memref.dealloc %17 : memref<6xi32>
    llvm.return
  }
}

