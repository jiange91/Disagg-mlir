Args: ./bin/standalone-pg ../example/from_cg/playground.mlir --convert-builtin-funcsig-to-remotemem -debug 
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubElementTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemRefLayoutAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubElementAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ElementsAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineBinaryOpExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineConstantExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineDimExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineMapStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::IntegerSetStorage)
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DebugActionManager::GenericHandler)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneRegion<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroSuccessors<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoRegionArguments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlock<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OpInvariants<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AffineScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsIsolatedFromAbove<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SymbolTable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasOnlyGraphRegion<Empty>)
Load new dialect in Context func
Load new dialect in Context cf
Load new dialect in Context arith
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectInlinerInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferizableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AutomaticAllocationScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface::Trait<Empty>)
Load new dialect in Context memref
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CopyOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ViewLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OffsetSizeAndStrideOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::PointerElementTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroRegions<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneResult<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NOperands<2>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ViewLikeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::MemRefsNormalizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ReturnLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AttrSizedOperandSegments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneOperand<Empty>)
Load new dialect in Context llvm
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMVoidType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMPPCFP128Type)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMX86MMXType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMTokenType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMLabelType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMMetadataType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMFunctionType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMPointerType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMFixedVectorType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMScalableVectorType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMArrayType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMStructType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::FastmathFlagsInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemRefElementTypeInterface)
Load new dialect in Context rmem
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::OpToOpPassAdaptor)

//===-------------------------------------------===//
Legalizing operation : 'builtin.module'(0x7f9fe6804250) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.func'(0x7f9fe68044a0) {
  * Fold {
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectFoldInterface)
  } -> FAILURE : unable to fold

  * Pattern : 'func.func -> ()' {
Trying to match "mlir::(anonymous namespace)::FuncOpDisagg"
    ** Insert  : 'func.func'(0x7f9fe681c450)
    ** Erase   : 'func.func'(0x7f9fe68044a0)
"mlir::(anonymous namespace)::FuncOpDisagg" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func.func'(0x7f9fe681c450) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: builtin.module
type of return operand 0 ('memref<6xi32>') doesn't match function result type ('!rmem.rmref<memref<6xi32>>') in function @memref_reshape
'func.func' op symbol declaration cannot have public visibility
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"builtin.module"() ({
  "func.func"() ({
  ^bb0(%arg0: !rmem.rmref<memref<2x3xi32>>, %arg1: !rmem.rmref<memref<1xi32>>):
    %0 = "memref.reshape"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
    "func.return"(%0) : (memref<6xi32>) -> ()
  }) {function_type = (!rmem.rmref<memref<2x3xi32>>, !rmem.rmref<memref<1xi32>>) -> !rmem.rmref<memref<6xi32>>, sym_name = "memref_reshape"} : () -> ()
  "func.func"() ({
  }) {function_type = (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>, sym_name = "memref_reshape"} : () -> ()
  "func.func"() ({
    %0 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<2x3xi32>
    %1 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xi32>
    %2 = "func.call"(%0, %1) {callee = @memref_reshape} : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
    "memref.dealloc"(%2) : (memref<6xi32>) -> ()
    "func.return"() : () -> ()
  }) {function_type = () -> (), sym_name = "main"} : () -> ()
}) : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.reshape'(0x7f9fe68041c0) {
  %0 = "memref.reshape"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.return'(0x7f9fe6804300) {
  "func.return"(%0) : (memref<6xi32>) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.return -> ()' {
Trying to match "mlir::(anonymous namespace)::FuncReturnOpDisagg"
    ** Insert  : 'func.return'(0x7f9fe5f1de20)
    ** Replace : 'func.return'(0x7f9fe6804300)
"mlir::(anonymous namespace)::FuncReturnOpDisagg" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func.return'(0x7f9fe5f1de20) {
      "func.return"(%1) : (!rmem.rmref<memref<6xi32>>) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
'func.return' op must be the last operation in the parent block
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() ({
^bb0(%arg0: !rmem.rmref<memref<2x3xi32>>, %arg1: !rmem.rmref<memref<1xi32>>):
  %0 = "memref.reshape"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
  %1 = "builtin.unrealized_conversion_cast"(%0) : (memref<6xi32>) -> !rmem.rmref<memref<6xi32>>
  "func.return"(%1) : (!rmem.rmref<memref<6xi32>>) -> ()
  "func.return"(%0) : (memref<6xi32>) -> ()
}) {function_type = (!rmem.rmref<memref<2x3xi32>>, !rmem.rmref<memref<1xi32>>) -> !rmem.rmref<memref<6xi32>>, sym_name = "memref_reshape"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.func'(0x7f9fe6805290) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.alloc'(0x7f9fe6804a70) {
  %0 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<2x3xi32>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.alloc'(0x7f9fe6804ba0) {
  %1 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xi32>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.call'(0x7f9fe6804fd0) {
  %2 = "func.call"(%0, %1) {callee = @memref_reshape} : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>

  * Fold {
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ConstantLike<Empty>)
  } -> FAILURE : unable to fold

  * Pattern : 'func.call -> ()' {
Trying to match "mlir::(anonymous namespace)::FuncCallOpDisagg"
    ** Insert  : 'func.call'(0x7f9fe5f1f880)
    ** Replace : 'func.call'(0x7f9fe6804fd0)
"mlir::(anonymous namespace)::FuncCallOpDisagg" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func.call'(0x7f9fe5f1f880) {
      %4 = "func.call"(%1, %3) {callee = @memref_reshape} : (!rmem.rmref<memref<2x3xi32>>, !rmem.rmref<memref<1xi32>>) -> !rmem.rmref<memref<6xi32>>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @main() {
  %0 = memref.alloc() : memref<2x3xi32>
  %1 = builtin.unrealized_conversion_cast %0 : memref<2x3xi32> to !rmem.rmref<memref<2x3xi32>>
  %2 = memref.alloc() : memref<1xi32>
  %3 = builtin.unrealized_conversion_cast %2 : memref<1xi32> to !rmem.rmref<memref<1xi32>>
  %4 = call @memref_reshape(%1, %3) : (!rmem.rmref<memref<2x3xi32>>, !rmem.rmref<memref<1xi32>>) -> !rmem.rmref<memref<6xi32>>
  %5 = call @memref_reshape(%0, %2) : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
  memref.dealloc %5 : memref<6xi32>
  return
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.dealloc'(0x7f9fe68050a0) {
  "memref.dealloc"(%5) : (memref<6xi32>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.return'(0x7f9fe6805110) {
  "func.return"() : () -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//
** Insert  : 'rmem.virtualize'(0x7f9fe5f1fde0)
** Insert  : 'rmem.virtualize'(0x7f9fe5f1f920)
** Insert  : 'rmem.virtualize'(0x7f9fe5f1c600)
** Insert  : 'rmem.materialize'(0x7f9fe5f1c680)
** Insert  : 'rmem.materialize'(0x7f9fe5f1c700)
** Insert  : 'rmem.materialize'(0x7f9fe5f1fbe0)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::PreservedAnalyses::AllAnalysesType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::rmem::RemoteMemRefType>::Impl<Empty>)
mlir-asm-printer: Verifying operation: builtin.module
module {
  func.func @memref_reshape(%arg0: !rmem.rmref<memref<2x3xi32>>, %arg1: !rmem.rmref<memref<1xi32>>) -> !rmem.rmref<memref<6xi32>> {
    %0 = rmem.materialize %arg1 : (!rmem.rmref<memref<1xi32>>) -> memref<1xi32>
    %1 = rmem.materialize %arg0 : (!rmem.rmref<memref<2x3xi32>>) -> memref<2x3xi32>
    %2 = memref.reshape %1(%0) : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
    %3 = rmem.virtualize(%2) : (memref<6xi32>) -> !rmem.rmref<memref<6xi32>>
    return %3 : !rmem.rmref<memref<6xi32>>
  }
  func.func @main() {
    %0 = memref.alloc() : memref<2x3xi32>
    %1 = rmem.virtualize(%0) : (memref<2x3xi32>) -> !rmem.rmref<memref<2x3xi32>>
    %2 = memref.alloc() : memref<1xi32>
    %3 = rmem.virtualize(%2) : (memref<1xi32>) -> !rmem.rmref<memref<1xi32>>
    %4 = call @memref_reshape(%1, %3) : (!rmem.rmref<memref<2x3xi32>>, !rmem.rmref<memref<1xi32>>) -> !rmem.rmref<memref<6xi32>>
    %5 = rmem.materialize %4 : (!rmem.rmref<memref<6xi32>>) -> memref<6xi32>
    memref.dealloc %5 : memref<6xi32>
    return
  }
}

