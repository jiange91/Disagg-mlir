Args: mlir-opt --convert-func-to-llvm ../example/from_cg/playground.mlir -debug 
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubElementTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemRefLayoutAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubElementAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ElementsAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineBinaryOpExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineConstantExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineDimExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineMapStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::IntegerSetStorage)
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DebugActionManager::GenericHandler)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneRegion<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroSuccessors<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoRegionArguments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlock<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OpInvariants<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AffineScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsIsolatedFromAbove<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SymbolTable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasOnlyGraphRegion<Empty>)
Load new dialect in Context func
Load new dialect in Context cf
Load new dialect in Context arith
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectInlinerInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferizableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AutomaticAllocationScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface::Trait<Empty>)
Load new dialect in Context memref
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CopyOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ViewLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OffsetSizeAndStrideOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroRegions<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneResult<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NOperands<2>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ViewLikeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::MemRefsNormalizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ReturnLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AttrSizedOperandSegments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneOperand<Empty>)
Load new dialect in Context llvm
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMVoidType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMPPCFP128Type)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMX86MMXType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMTokenType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMLabelType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMMetadataType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMFunctionType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMPointerType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMFixedVectorType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMScalableVectorType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMArrayType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMStructType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::FastmathFlagsInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutAnalysis)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutOpInterface)

//===-------------------------------------------===//
Legalizing operation : 'builtin.module'(0x7fae8b8195d0) {
  * Fold {
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectFoldInterface)
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.func'(0x7fae8b91d2c0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.func -> ()' {
Trying to match "(anonymous namespace)::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x7fae8b831f30)
    ** Erase   : 'func.func'(0x7fae8b91d2c0)
"(anonymous namespace)::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x7fae8b831f30) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: builtin.module
'func.return' op expects parent op 'func.func'
'func.func' op symbol declaration cannot have public visibility
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"builtin.module"() ({
  "llvm.func"() ({
  ^bb0(%arg0: !llvm.ptr<i32>, %arg1: !llvm.ptr<i32>, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i64, %arg7: !llvm.ptr<i32>, %arg8: !llvm.ptr<i32>, %arg9: i64, %arg10: i64, %arg11: i64):
    %0 = "builtin.unrealized_conversion_cast"(%arg0, %arg1, %arg2, %arg3, %arg4, %arg5, %arg6) : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %1 = "builtin.unrealized_conversion_cast"(%arg7, %arg8, %arg9, %arg10, %arg11) : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %2 = "memref.reshape"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
    "func.return"(%2) : (memref<6xi32>) -> ()
  }) {function_type = !llvm.func<struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)> (ptr<i32>, ptr<i32>, i64, i64, i64, i64, i64, ptr<i32>, ptr<i32>, i64, i64, i64)>, linkage = #llvm.linkage<external>, sym_name = "memref_reshape"} : () -> ()
  "func.func"() ({
  }) {function_type = (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>, sym_name = "memref_reshape"} : () -> ()
  "func.func"() ({
    %0 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<2x3xi32>
    %1 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xi32>
    %2 = "func.call"(%0, %1) {callee = @memref_reshape} : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
    "memref.dealloc"(%2) : (memref<6xi32>) -> ()
    "func.return"() : () -> ()
  }) {function_type = () -> (), sym_name = "main"} : () -> ()
}) : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.reshape'(0x7fae8b91d230) {
  %2 = "memref.reshape"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.return'(0x7fae8b91b790) {
  "func.return"(%2) : (memref<6xi32>) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.return -> ()' {
Trying to match "(anonymous namespace)::ReturnOpLowering"
    ** Insert  : 'llvm.return'(0x7fae8b832c30)
    ** Replace : 'func.return'(0x7fae8b91b790)
"(anonymous namespace)::ReturnOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.return'(0x7fae8b832c30) {
      "llvm.return"(%3) : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'llvm.return' op must be the last operation in the parent block
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: !llvm.ptr<i32>, %arg1: !llvm.ptr<i32>, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i64, %arg7: !llvm.ptr<i32>, %arg8: !llvm.ptr<i32>, %arg9: i64, %arg10: i64, %arg11: i64):
  %0 = "builtin.unrealized_conversion_cast"(%arg0, %arg1, %arg2, %arg3, %arg4, %arg5, %arg6) : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
  %1 = "builtin.unrealized_conversion_cast"(%arg7, %arg8, %arg9, %arg10, %arg11) : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
  %2 = "memref.reshape"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
  %3 = "builtin.unrealized_conversion_cast"(%2) : (memref<6xi32>) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
  "llvm.return"(%3) : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> ()
  "func.return"(%2) : (memref<6xi32>) -> ()
}) {function_type = !llvm.func<struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)> (ptr<i32>, ptr<i32>, i64, i64, i64, i64, i64, ptr<i32>, ptr<i32>, i64, i64, i64)>, linkage = #llvm.linkage<external>, sym_name = "memref_reshape"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.func'(0x7fae8b819cc0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.func -> ()' {
Trying to match "(anonymous namespace)::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x7fae8bb04b50)
    ** Erase   : 'func.func'(0x7fae8b819cc0)
"(anonymous namespace)::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x7fae8bb04b50) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: builtin.module
'llvm.return' op must be the last operation in the parent block
'func.func' op symbol declaration cannot have public visibility
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"builtin.module"() ({
  "llvm.func"() ({
  ^bb0(%arg0: !llvm.ptr<i32>, %arg1: !llvm.ptr<i32>, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i64, %arg7: !llvm.ptr<i32>, %arg8: !llvm.ptr<i32>, %arg9: i64, %arg10: i64, %arg11: i64):
    %0 = "builtin.unrealized_conversion_cast"(%arg0, %arg1, %arg2, %arg3, %arg4, %arg5, %arg6) : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %1 = "builtin.unrealized_conversion_cast"(%arg7, %arg8, %arg9, %arg10, %arg11) : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %2 = "memref.reshape"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
    %3 = "builtin.unrealized_conversion_cast"(%2) : (memref<6xi32>) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    "llvm.return"(%3) : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> ()
    "func.return"(%2) : (memref<6xi32>) -> ()
  }) {function_type = !llvm.func<struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)> (ptr<i32>, ptr<i32>, i64, i64, i64, i64, i64, ptr<i32>, ptr<i32>, i64, i64, i64)>, linkage = #llvm.linkage<external>, sym_name = "memref_reshape"} : () -> ()
  "func.func"() ({
  }) {function_type = (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>, sym_name = "memref_reshape"} : () -> ()
  "llvm.func"() ({
    %0 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<2x3xi32>
    %1 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xi32>
    %2 = "func.call"(%0, %1) {callee = @memref_reshape} : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
    "memref.dealloc"(%2) : (memref<6xi32>) -> ()
    "func.return"() : () -> ()
  }) {function_type = !llvm.func<void ()>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()
  "func.func"() ({
  }) {function_type = () -> (), sym_name = "main"} : () -> ()
}) : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.alloc'(0x7fae8b818c80) {
  %0 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<2x3xi32>

  * Fold {
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ConstantLike<Empty>)
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.alloc'(0x7fae8b818ce0) {
  %1 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xi32>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.call'(0x7fae8b819910) {
  %2 = "func.call"(%0, %1) {callee = @memref_reshape} : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.call -> ()' {
Trying to match "(anonymous namespace)::CallOpLowering"
    ** Insert  : 'llvm.extractvalue'(0x7fae8af062b0)
    ** Insert  : 'llvm.extractvalue'(0x7fae8af06460)
    ** Insert  : 'llvm.extractvalue'(0x7fae8af064e0)
    ** Insert  : 'llvm.extractvalue'(0x7fae8af06a90)
    ** Insert  : 'llvm.extractvalue'(0x7fae8af06b10)
    ** Insert  : 'llvm.extractvalue'(0x7fae8af06b90)
    ** Insert  : 'llvm.extractvalue'(0x7fae8af06d40)
    ** Insert  : 'llvm.extractvalue'(0x7fae8af06e60)
    ** Insert  : 'llvm.extractvalue'(0x7fae8af06ee0)
    ** Insert  : 'llvm.extractvalue'(0x7fae8af06f60)
    ** Insert  : 'llvm.extractvalue'(0x7fae8af06fe0)
    ** Insert  : 'llvm.extractvalue'(0x7fae8af07140)
    ** Insert  : 'llvm.call'(0x7fae8af07220)
    ** Replace : 'func.call'(0x7fae8b819910)
"(anonymous namespace)::CallOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fae8af062b0) {
      %4 = "llvm.extractvalue"(%1) {position = [0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> !llvm.ptr<i32>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fae8af06460) {
      %5 = "llvm.extractvalue"(%1) {position = [1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> !llvm.ptr<i32>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fae8af064e0) {
      %6 = "llvm.extractvalue"(%1) {position = [2]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fae8af06a90) {
      %7 = "llvm.extractvalue"(%1) {position = [3, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fae8af06b10) {
      %8 = "llvm.extractvalue"(%1) {position = [3, 1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fae8af06b90) {
      %9 = "llvm.extractvalue"(%1) {position = [4, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fae8af06d40) {
      %10 = "llvm.extractvalue"(%1) {position = [4, 1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fae8af06e60) {
      %11 = "llvm.extractvalue"(%3) {position = [0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> !llvm.ptr<i32>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fae8af06ee0) {
      %12 = "llvm.extractvalue"(%3) {position = [1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> !llvm.ptr<i32>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fae8af06f60) {
      %13 = "llvm.extractvalue"(%3) {position = [2]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fae8af06fe0) {
      %14 = "llvm.extractvalue"(%3) {position = [3, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x7fae8af07140) {
      %15 = "llvm.extractvalue"(%3) {position = [4, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.call'(0x7fae8af07220) {
      %16 = "llvm.call"(%4, %5, %6, %7, %8, %9, %10, %11, %12, %13, %14, %15) {callee = @memref_reshape} : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64, i64, i64, !llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::FastmathFlagsInterface::Trait<Empty>)
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
  %0 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<2x3xi32>
  %1 = "builtin.unrealized_conversion_cast"(%0) : (memref<2x3xi32>) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
  %2 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xi32>
  %3 = "builtin.unrealized_conversion_cast"(%2) : (memref<1xi32>) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
  %4 = "llvm.extractvalue"(%1) {position = [0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> !llvm.ptr<i32>
  %5 = "llvm.extractvalue"(%1) {position = [1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> !llvm.ptr<i32>
  %6 = "llvm.extractvalue"(%1) {position = [2]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %7 = "llvm.extractvalue"(%1) {position = [3, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %8 = "llvm.extractvalue"(%1) {position = [3, 1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %9 = "llvm.extractvalue"(%1) {position = [4, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %10 = "llvm.extractvalue"(%1) {position = [4, 1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %11 = "llvm.extractvalue"(%3) {position = [0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> !llvm.ptr<i32>
  %12 = "llvm.extractvalue"(%3) {position = [1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> !llvm.ptr<i32>
  %13 = "llvm.extractvalue"(%3) {position = [2]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64
  %14 = "llvm.extractvalue"(%3) {position = [3, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64
  %15 = "llvm.extractvalue"(%3) {position = [4, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64
  %16 = "llvm.call"(%4, %5, %6, %7, %8, %9, %10, %11, %12, %13, %14, %15) {callee = @memref_reshape} : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64, i64, i64, !llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
  %17 = "func.call"(%0, %2) {callee = @memref_reshape} : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
  "memref.dealloc"(%17) : (memref<6xi32>) -> ()
  "func.return"() : () -> ()
}) {function_type = !llvm.func<void ()>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'memref.dealloc'(0x7fae8b8199a0) {
  "memref.dealloc"(%17) : (memref<6xi32>) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.return'(0x7fae8b819b40) {
  "func.return"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.return -> ()' {
Trying to match "(anonymous namespace)::ReturnOpLowering"
    ** Insert  : 'llvm.return'(0x7fae8af05fb0)
    ** Replace : 'func.return'(0x7fae8b819b40)
"(anonymous namespace)::ReturnOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.return'(0x7fae8af05fb0) {
      "llvm.return"() : () -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'llvm.return' op must be the last operation in the parent block
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
  %0 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<2x3xi32>
  %1 = "builtin.unrealized_conversion_cast"(%0) : (memref<2x3xi32>) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
  %2 = "memref.alloc"() {operand_segment_sizes = dense<0> : vector<2xi32>} : () -> memref<1xi32>
  %3 = "builtin.unrealized_conversion_cast"(%2) : (memref<1xi32>) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
  %4 = "llvm.extractvalue"(%1) {position = [0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> !llvm.ptr<i32>
  %5 = "llvm.extractvalue"(%1) {position = [1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> !llvm.ptr<i32>
  %6 = "llvm.extractvalue"(%1) {position = [2]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %7 = "llvm.extractvalue"(%1) {position = [3, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %8 = "llvm.extractvalue"(%1) {position = [3, 1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %9 = "llvm.extractvalue"(%1) {position = [4, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %10 = "llvm.extractvalue"(%1) {position = [4, 1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>) -> i64
  %11 = "llvm.extractvalue"(%3) {position = [0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> !llvm.ptr<i32>
  %12 = "llvm.extractvalue"(%3) {position = [1]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> !llvm.ptr<i32>
  %13 = "llvm.extractvalue"(%3) {position = [2]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64
  %14 = "llvm.extractvalue"(%3) {position = [3, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64
  %15 = "llvm.extractvalue"(%3) {position = [4, 0]} : (!llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>) -> i64
  %16 = "llvm.call"(%4, %5, %6, %7, %8, %9, %10, %11, %12, %13, %14, %15) {callee = @memref_reshape} : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64, i64, i64, !llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
  %17 = "func.call"(%0, %2) {callee = @memref_reshape} : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
  "memref.dealloc"(%17) : (memref<6xi32>) -> ()
  "llvm.return"() : () -> ()
  "func.return"() : () -> ()
}) {function_type = !llvm.func<void ()>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//
** Insert  : 'builtin.unrealized_conversion_cast'(0x7fae8bc04590)
** Insert  : 'builtin.unrealized_conversion_cast'(0x7fae8bc04610)
** Insert  : 'builtin.unrealized_conversion_cast'(0x7fae8bc04690)
** Insert  : 'llvm.mlir.undef'(0x7fae8bc040a0)
** Insert  : 'llvm.insertvalue'(0x7fae8bc04710)
** Insert  : 'llvm.insertvalue'(0x7fae8bc047b0)
** Insert  : 'llvm.insertvalue'(0x7fae8bc04850)
** Insert  : 'llvm.insertvalue'(0x7fae8bc048f0)
** Insert  : 'llvm.insertvalue'(0x7fae8bc04990)
** Insert  : 'llvm.mlir.undef'(0x7fae8bc04a70)
** Insert  : 'llvm.insertvalue'(0x7fae8bc04ac0)
** Insert  : 'llvm.insertvalue'(0x7fae8bc04b60)
** Insert  : 'llvm.insertvalue'(0x7fae8bc04c00)
** Insert  : 'llvm.insertvalue'(0x7fae8bc04e90)
** Insert  : 'llvm.insertvalue'(0x7fae8bc04f30)
** Insert  : 'llvm.insertvalue'(0x7fae8bc04fd0)
** Insert  : 'llvm.insertvalue'(0x7fae8bc05070)
** Insert  : 'builtin.unrealized_conversion_cast'(0x7fae8bc04350)
** Insert  : 'builtin.unrealized_conversion_cast'(0x7fae8bc043d0)
** Insert  : 'builtin.unrealized_conversion_cast'(0x7fae8bc04450)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::PreservedAnalyses::AllAnalysesType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutSpecInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface::Trait<Empty>)
mlir-asm-printer: Verifying operation: builtin.module
module attributes {llvm.data_layout = ""} {
  llvm.func @memref_reshape(%arg0: !llvm.ptr<i32>, %arg1: !llvm.ptr<i32>, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i64, %arg7: !llvm.ptr<i32>, %arg8: !llvm.ptr<i32>, %arg9: i64, %arg10: i64, %arg11: i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)> {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %5 = llvm.insertvalue %arg5, %4[4, 0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %6 = llvm.insertvalue %arg4, %5[3, 1] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %7 = llvm.insertvalue %arg6, %6[4, 1] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %8 = builtin.unrealized_conversion_cast %7 : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)> to memref<2x3xi32>
    %9 = llvm.mlir.undef : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %10 = llvm.insertvalue %arg7, %9[0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %11 = llvm.insertvalue %arg8, %10[1] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %12 = llvm.insertvalue %arg9, %11[2] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %arg10, %12[3, 0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %14 = llvm.insertvalue %arg11, %13[4, 0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %15 = builtin.unrealized_conversion_cast %14 : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)> to memref<1xi32>
    %16 = memref.reshape %8(%15) : (memref<2x3xi32>, memref<1xi32>) -> memref<6xi32>
    %17 = builtin.unrealized_conversion_cast %16 : memref<6xi32> to !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    llvm.return %17 : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
  }
  llvm.func @main() {
    %0 = memref.alloc() : memref<2x3xi32>
    %1 = builtin.unrealized_conversion_cast %0 : memref<2x3xi32> to !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %2 = memref.alloc() : memref<1xi32>
    %3 = builtin.unrealized_conversion_cast %2 : memref<1xi32> to !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %4 = llvm.extractvalue %1[0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %5 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %6 = llvm.extractvalue %1[2] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %7 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %8 = llvm.extractvalue %1[3, 1] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %9 = llvm.extractvalue %1[4, 0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %10 = llvm.extractvalue %1[4, 1] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<2 x i64>, array<2 x i64>)>
    %11 = llvm.extractvalue %3[0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %12 = llvm.extractvalue %3[1] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.extractvalue %3[2] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %14 = llvm.extractvalue %3[3, 0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %15 = llvm.extractvalue %3[4, 0] : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %16 = llvm.call @memref_reshape(%4, %5, %6, %7, %8, %9, %10, %11, %12, %13, %14, %15) : (!llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64, i64, i64, !llvm.ptr<i32>, !llvm.ptr<i32>, i64, i64, i64) -> !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)>
    %17 = builtin.unrealized_conversion_cast %16 : !llvm.struct<(ptr<i32>, ptr<i32>, i64, array<1 x i64>, array<1 x i64>)> to memref<6xi32>
    memref.dealloc %17 : memref<6xi32>
    llvm.return
  }
}

