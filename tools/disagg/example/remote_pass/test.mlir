Args: ./bin/standalone-pg ../example/from_cg/test.mlir --convert-builtin-funcsig-to-remotemem -debug 
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubElementTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemRefLayoutAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubElementAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ElementsAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineBinaryOpExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineConstantExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineDimExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineMapStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::IntegerSetStorage)
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DebugActionManager::GenericHandler)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneRegion<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroSuccessors<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoRegionArguments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlock<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OpInvariants<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AffineScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsIsolatedFromAbove<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SymbolTable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasOnlyGraphRegion<Empty>)
Load new dialect in Context dlti
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutEntryAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutEntryInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutSpecAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutSpecInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutDialectInterface)
Load new dialect in Context llvm
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMVoidType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMPPCFP128Type)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMX86MMXType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMTokenType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMLabelType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMMetadataType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMFunctionType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMPointerType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMFixedVectorType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMScalableVectorType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMArrayType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMStructType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::FastmathFlagsInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemRefElementTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::PointerElementTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AutomaticAllocationScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlockImplicitTerminator<mlir::LLVM::ReturnOp>::Impl<Empty>)
Load new dialect in Context func
Load new dialect in Context cf
Load new dialect in Context arith
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectInlinerInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferizableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroRegions<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneResult<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ConstantLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::FastmathFlagsInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneOperand<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NOperands<2>::Impl<Empty>)
Load new dialect in Context scf
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchTerminatorOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LoopLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AtLeastNOperands<3>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LoopLikeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasRecursiveSideEffects<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameOperandsAndResultShape<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Elementwise<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Scalarizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Vectorizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Tensorizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp, mlir::scf::ForOp, mlir::scf::IfOp, mlir::scf::ParallelOp, mlir::scf::WhileOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ReturnLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::MemRefsNormalizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameTypeOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NRegions<2>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::LLVM::LLVMPointerType>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsCommutative<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameOperandsAndResultType<Empty>)
Load new dialect in Context rmem
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::OpToOpPassAdaptor)

//===-------------------------------------------===//
Legalizing operation : 'builtin.module'(0x7fc6af107230) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x7fc6ae723770) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.global'(0x7fc6ae7245b0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x7fc6ae724060) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.func'(0x7fc6af104930) {
  * Fold {
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectFoldInterface)
  } -> FAILURE : unable to fold

  * Pattern : 'func.func -> ()' {
Trying to match "mlir::(anonymous namespace)::FuncOpDisagg"
    ** Insert  : 'func.func'(0x7fc6af204440)
    ** Erase   : 'func.func'(0x7fc6af104930)
"mlir::(anonymous namespace)::FuncOpDisagg" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func.func'(0x7fc6af204440) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: builtin.module
'func.func' op symbol declaration cannot have public visibility
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"builtin.module"() ({
  "llvm.func"() ({
  }) {function_type = !llvm.func<i32 (ptr<i8>, ...)>, linkage = #llvm.linkage<external>, sym_name = "printf"} : () -> ()
  "llvm.mlir.global"() ({
  }) {addr_space = 0 : i32, constant, global_type = !llvm.array<33 x i8>, linkage = #llvm.linkage<internal>, sym_name = "str0", unnamed_addr = 0 : i64, value = "Too many neighbours for node %d\0A\00"} : () -> ()
  "llvm.func"() ({
  }) {function_type = !llvm.func<ptr<i8> (i64)>, linkage = #llvm.linkage<external>, sym_name = "malloc"} : () -> ()
  "func.func"() ({
  ^bb0(%arg0: i32, %arg1: !rmem.rmref<!llvm.ptr<!rmem.rmref<!llvm.ptr<i8>>>>):
    %0 = "arith.constant"() {value = 2000000 : index} : () -> index
    %1 = "arith.constant"() {value = 0 : index} : () -> index
    %2 = "arith.constant"() {value = 1 : index} : () -> index
    %3 = "arith.constant"() {value = 16 : i64} : () -> i64
    %4 = "arith.constant"() {value = 272000000 : i64} : () -> i64
    %5 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
    %6 = "arith.constant"() {value = 1 : i32} : () -> i32
    %7 = "arith.constant"() {value = 0 : i32} : () -> i32
    %8 = "llvm.call"(%3) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %9 = "llvm.bitcast"(%8) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
    %10 = "llvm.getelementptr"(%9) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %11 = "llvm.call"(%4) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %12 = "llvm.bitcast"(%11) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    "llvm.store"(%12, %10) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
    "scf.for"(%1, %0, %2) ({
    ^bb0(%arg2: index):
      %13 = "llvm.getelementptr"(%9) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
      %14 = "llvm.load"(%13) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
      %15 = "arith.index_cast"(%arg2) : (index) -> i64
      %16 = "llvm.getelementptr"(%14, %15) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
      %17 = "llvm.getelementptr"(%16) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
      "llvm.store"(%7, %17) : (i32, !llvm.ptr<i32>) -> ()
      "scf.yield"() : () -> ()
    }) : (index, index, index) -> ()
    "func.call"(%9, %7, %6, %5) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
    "func.return"(%7) : (i32) -> ()
  }) {function_type = (i32, !rmem.rmref<!llvm.ptr<!rmem.rmref<!llvm.ptr<i8>>>>) -> i32, sym_name = "main"} : () -> ()
  "func.func"() ({
  }) {function_type = (i32, !llvm.ptr<ptr<i8>>) -> i32, llvm.linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()
  "func.func"() ({
  ^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
    %0 = "arith.constant"() {value = 1 : i32} : () -> i32
    %1 = "arith.constant"() {value = 16 : i32} : () -> i32
    %2 = "llvm.getelementptr"(%arg0) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %3 = "llvm.load"(%2) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %4 = "arith.index_cast"(%arg1) : (i32) -> index
    %5 = "arith.index_cast"(%4) : (index) -> i64
    %6 = "llvm.getelementptr"(%3, %5) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %7 = "llvm.getelementptr"(%6) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %8 = "llvm.load"(%7) : (!llvm.ptr<i32>) -> i32
    %9 = "arith.cmpi"(%8, %1) {predicate = 5 : i64} : (i32, i32) -> i1
    "scf.if"(%9) ({
      %24 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
      %25 = "llvm.getelementptr"(%24) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
      %26 = "llvm.call"(%25, %arg1) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
      "func.call"(%0) {callee = @exit} : (i32) -> ()
      "scf.yield"() : () -> ()
    }, {
    }) : (i1) -> ()
    %10 = "llvm.getelementptr"(%arg0) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %11 = "llvm.load"(%10) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %12 = "arith.index_cast"(%arg1) : (i32) -> index
    %13 = "arith.index_cast"(%12) : (index) -> i64
    %14 = "llvm.getelementptr"(%11, %13) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %15 = "llvm.getelementptr"(%14) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
    %16 = "llvm.getelementptr"(%15) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %17 = "llvm.getelementptr"(%14) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %18 = "llvm.load"(%17) : (!llvm.ptr<i32>) -> i32
    %19 = "arith.addi"(%18, %0) : (i32, i32) -> i32
    "llvm.store"(%19, %17) : (i32, !llvm.ptr<i32>) -> ()
    %20 = "arith.index_cast"(%18) : (i32) -> index
    %21 = "arith.index_cast"(%20) : (index) -> i64
    %22 = "llvm.getelementptr"(%16, %21) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %23 = "func.call"(%arg2, %arg3) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
    "llvm.store"(%23, %22) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
    "func.return"() : () -> ()
  }) {function_type = (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> (), llvm.linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()
  "func.func"() ({
  }) {function_type = (i32) -> (), llvm.linkage = #llvm.linkage<external>, sym_name = "exit", sym_visibility = "private"} : () -> ()
  "func.func"() ({
  ^bb0(%arg0: i32, %arg1: f64):
    %0 = "arith.constant"() {value = 16 : i64} : () -> i64
    %1 = "llvm.call"(%0) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %2 = "llvm.bitcast"(%1) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(f64, i32)>>
    %3 = "llvm.getelementptr"(%2) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(%arg0, %3) : (i32, !llvm.ptr<i32>) -> ()
    %4 = "llvm.getelementptr"(%2) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<f64>
    "llvm.store"(%arg1, %4) : (f64, !llvm.ptr<f64>) -> ()
    "func.return"(%2) : (!llvm.ptr<struct<(f64, i32)>>) -> ()
  }) {function_type = (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>, llvm.linkage = #llvm.linkage<external>, sym_name = "new_graph_node"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fc6ae72b2d0) {
  %0 = "arith.constant"() {value = 2000000 : index} : () -> index

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fc6ae72b380) {
  %1 = "arith.constant"() {value = 0 : index} : () -> index

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fc6ae72b540) {
  %2 = "arith.constant"() {value = 1 : index} : () -> index

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fc6ae72b830) {
  %3 = "arith.constant"() {value = 16 : i64} : () -> i64

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fc6ae72b8e0) {
  %4 = "arith.constant"() {value = 272000000 : i64} : () -> i64

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fc6ae72bad0) {
  %5 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fc6ae72bc80) {
  %6 = "arith.constant"() {value = 1 : i32} : () -> i32

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fc6ae72bd10) {
  %7 = "arith.constant"() {value = 0 : i32} : () -> i32

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x7fc6ae72c180) {
  %8 = "llvm.call"(%3) {callee = @malloc} : (i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x7fc6ae72c9c0) {
  %9 = "llvm.bitcast"(%8) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fc6ae72cf70) {
  %10 = "llvm.getelementptr"(%9) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x7fc6ae72ae70) {
  %11 = "llvm.call"(%4) {callee = @malloc} : (i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x7fc6ae72ad70) {
  %12 = "llvm.bitcast"(%11) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x7fc6ae72d300) {
  "llvm.store"(%12, %10) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'scf.for'(0x7fc6af1045c0) {
  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fc6ae72e730) {
  %13 = "llvm.getelementptr"(%9) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x7fc6ae72e7b0) {
  %14 = "llvm.load"(%13) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.index_cast'(0x7fc6ae72e830) {
  %15 = "arith.index_cast"(%arg2) : (index) -> i64

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fc6af104250) {
  %16 = "llvm.getelementptr"(%14, %15) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fc6af1044c0) {
  %17 = "llvm.getelementptr"(%16) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x7fc6af104530) {
  "llvm.store"(%7, %17) : (i32, !llvm.ptr<i32>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'scf.yield'(0x7fc6af1040c0) {
  "scf.yield"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.call'(0x7fc6af1047f0) {
  "func.call"(%9, %7, %6, %5) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.call -> ()' {
Trying to match "mlir::(anonymous namespace)::FuncCallOpDisagg"
    ** Insert  : 'func.call'(0x7fc6af108c90)
    ** Replace : 'func.call'(0x7fc6af1047f0)
"mlir::(anonymous namespace)::FuncCallOpDisagg" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func.call'(0x7fc6af108c90) {
      "func.call"(%10, %7, %6, %5) {callee = @add_edge} : (!rmem.rmref<!llvm.ptr<!llvm.struct<(!rmem.rmref<!llvm.ptr<!llvm.struct<(!llvm.array<16 x !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>>, i32)>>>, i32)>>>, i32, i32, f64) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
func.func @main(%arg0: i32, %arg1: !rmem.rmref<!llvm.ptr<!rmem.rmref<!llvm.ptr<i8>>>>) -> i32 {
  %c2000000 = arith.constant 2000000 : index
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %c16_i64 = arith.constant 16 : i64
  %c272000000_i64 = arith.constant 272000000 : i64
  %cst = arith.constant 5.000000e-01 : f64
  %c1_i32 = arith.constant 1 : i32
  %c0_i32 = arith.constant 0 : i32
  %0 = llvm.call @malloc(%c16_i64) : (i64) -> !llvm.ptr<i8>
  %1 = llvm.bitcast %0 : !llvm.ptr<i8> to !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
  %2 = builtin.unrealized_conversion_cast %1 : !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>> to !rmem.rmref<!llvm.ptr<!llvm.struct<(!rmem.rmref<!llvm.ptr<!llvm.struct<(!llvm.array<16 x !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>>, i32)>>>, i32)>>>
  %3 = llvm.getelementptr %1[0, 0] : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %4 = llvm.call @malloc(%c272000000_i64) : (i64) -> !llvm.ptr<i8>
  %5 = llvm.bitcast %4 : !llvm.ptr<i8> to !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  llvm.store %5, %3 : !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  scf.for %arg2 = %c0 to %c2000000 step %c1 {
    %6 = llvm.getelementptr %1[0, 0] : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %7 = llvm.load %6 : !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %8 = arith.index_cast %arg2 : index to i64
    %9 = llvm.getelementptr %7[%8] : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %10 = llvm.getelementptr %9[0, 1] : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    llvm.store %c0_i32, %10 : !llvm.ptr<i32>
  }
  call @add_edge(%2, %c0_i32, %c1_i32, %cst) : (!rmem.rmref<!llvm.ptr<!llvm.struct<(!rmem.rmref<!llvm.ptr<!llvm.struct<(!llvm.array<16 x !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>>, i32)>>>, i32)>>>, i32, i32, f64) -> ()
  call @add_edge(%1, %c0_i32, %c1_i32, %cst) : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
  return %c0_i32 : i32
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.return'(0x7fc6af1048c0) {
  "func.return"(%7) : (i32) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.func'(0x7fc6af106750) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.func -> ()' {
Trying to match "mlir::(anonymous namespace)::FuncOpDisagg"
reach target
    ** Insert  : 'func.func'(0x7fc6af00a890)
    ** Erase   : 'func.func'(0x7fc6af106750)
"mlir::(anonymous namespace)::FuncOpDisagg" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func.func'(0x7fc6af00a890) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: builtin.module
'func.func' op symbol declaration cannot have public visibility
'llvm.getelementptr' op using value defined outside the region
'func.func' op symbol declaration cannot have public visibility
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"builtin.module"() ({
  "llvm.func"() ({
  }) {function_type = !llvm.func<i32 (ptr<i8>, ...)>, linkage = #llvm.linkage<external>, sym_name = "printf"} : () -> ()
  "llvm.mlir.global"() ({
  }) {addr_space = 0 : i32, constant, global_type = !llvm.array<33 x i8>, linkage = #llvm.linkage<internal>, sym_name = "str0", unnamed_addr = 0 : i64, value = "Too many neighbours for node %d\0A\00"} : () -> ()
  "llvm.func"() ({
  }) {function_type = !llvm.func<ptr<i8> (i64)>, linkage = #llvm.linkage<external>, sym_name = "malloc"} : () -> ()
  "func.func"() ({
  ^bb0(%arg0: i32, %arg1: !rmem.rmref<!llvm.ptr<!rmem.rmref<!llvm.ptr<i8>>>>):
    %0 = "arith.constant"() {value = 2000000 : index} : () -> index
    %1 = "arith.constant"() {value = 0 : index} : () -> index
    %2 = "arith.constant"() {value = 1 : index} : () -> index
    %3 = "arith.constant"() {value = 16 : i64} : () -> i64
    %4 = "arith.constant"() {value = 272000000 : i64} : () -> i64
    %5 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
    %6 = "arith.constant"() {value = 1 : i32} : () -> i32
    %7 = "arith.constant"() {value = 0 : i32} : () -> i32
    %8 = "llvm.call"(%3) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %9 = "llvm.bitcast"(%8) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
    %10 = "builtin.unrealized_conversion_cast"(%9) : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !rmem.rmref<!llvm.ptr<!llvm.struct<(!rmem.rmref<!llvm.ptr<!llvm.struct<(!llvm.array<16 x !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>>, i32)>>>, i32)>>>
    %11 = "llvm.getelementptr"(%9) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %12 = "llvm.call"(%4) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %13 = "llvm.bitcast"(%12) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    "llvm.store"(%13, %11) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
    "scf.for"(%1, %0, %2) ({
    ^bb0(%arg2: index):
      %14 = "llvm.getelementptr"(%9) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
      %15 = "llvm.load"(%14) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
      %16 = "arith.index_cast"(%arg2) : (index) -> i64
      %17 = "llvm.getelementptr"(%15, %16) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
      %18 = "llvm.getelementptr"(%17) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
      "llvm.store"(%7, %18) : (i32, !llvm.ptr<i32>) -> ()
      "scf.yield"() : () -> ()
    }) : (index, index, index) -> ()
    "func.call"(%10, %7, %6, %5) {callee = @add_edge} : (!rmem.rmref<!llvm.ptr<!llvm.struct<(!rmem.rmref<!llvm.ptr<!llvm.struct<(!llvm.array<16 x !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>>, i32)>>>, i32)>>>, i32, i32, f64) -> ()
    "func.call"(%9, %7, %6, %5) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
    "func.return"(%7) : (i32) -> ()
  }) {function_type = (i32, !rmem.rmref<!llvm.ptr<!rmem.rmref<!llvm.ptr<i8>>>>) -> i32, sym_name = "main"} : () -> ()
  "func.func"() ({
  }) {function_type = (i32, !llvm.ptr<ptr<i8>>) -> i32, llvm.linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()
  "func.func"() ({
  ^bb0(%arg0: !rmem.rmref<!llvm.ptr<!llvm.struct<(!rmem.rmref<!llvm.ptr<!llvm.struct<(!llvm.array<16 x !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>>, i32)>>>, i32)>>>, %arg1: i32, %arg2: i32, %arg3: f64):
    %0 = "arith.constant"() {value = 1 : i32} : () -> i32
    %1 = "arith.constant"() {value = 16 : i32} : () -> i32
    %2 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %3 = "llvm.load"(%2) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %4 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
    %5 = "arith.index_cast"(%4) : (index) -> i64
    %6 = "llvm.getelementptr"(%3, %5) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %7 = "llvm.getelementptr"(%6) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %8 = "llvm.load"(%7) : (!llvm.ptr<i32>) -> i32
    %9 = "arith.cmpi"(%8, %1) {predicate = 5 : i64} : (i32, i32) -> i1
    "scf.if"(%9) ({
      %24 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
      %25 = "llvm.getelementptr"(%24) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
      %26 = "llvm.call"(%25, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
      "func.call"(%0) {callee = @exit} : (i32) -> ()
      "scf.yield"() : () -> ()
    }, {
    }) : (i1) -> ()
    %10 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %11 = "llvm.load"(%10) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %12 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
    %13 = "arith.index_cast"(%12) : (index) -> i64
    %14 = "llvm.getelementptr"(%11, %13) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %15 = "llvm.getelementptr"(%14) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
    %16 = "llvm.getelementptr"(%15) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %17 = "llvm.getelementptr"(%14) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %18 = "llvm.load"(%17) : (!llvm.ptr<i32>) -> i32
    %19 = "arith.addi"(%18, %0) : (i32, i32) -> i32
    "llvm.store"(%19, %17) : (i32, !llvm.ptr<i32>) -> ()
    %20 = "arith.index_cast"(%18) : (i32) -> index
    %21 = "arith.index_cast"(%20) : (index) -> i64
    %22 = "llvm.getelementptr"(%16, %21) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %23 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
    "llvm.store"(%23, %22) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
    "func.return"() : () -> ()
  }) {function_type = (!rmem.rmref<!llvm.ptr<!llvm.struct<(!rmem.rmref<!llvm.ptr<!llvm.struct<(!llvm.array<16 x !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>>, i32)>>>, i32)>>>, i32, i32, f64) -> (), sym_name = "add_edge"} : () -> ()
  "func.func"() ({
  }) {function_type = (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> (), llvm.linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()
  "func.func"() ({
  }) {function_type = (i32) -> (), llvm.linkage = #llvm.linkage<external>, sym_name = "exit", sym_visibility = "private"} : () -> ()
  "func.func"() ({
  ^bb0(%arg0: i32, %arg1: f64):
    %0 = "arith.constant"() {value = 16 : i64} : () -> i64
    %1 = "llvm.call"(%0) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %2 = "llvm.bitcast"(%1) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(f64, i32)>>
    %3 = "llvm.getelementptr"(%2) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(%arg0, %3) : (i32, !llvm.ptr<i32>) -> ()
    %4 = "llvm.getelementptr"(%2) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<f64>
    "llvm.store"(%arg1, %4) : (f64, !llvm.ptr<f64>) -> ()
    "func.return"(%2) : (!llvm.ptr<struct<(f64, i32)>>) -> ()
  }) {function_type = (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>, llvm.linkage = #llvm.linkage<external>, sym_name = "new_graph_node"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fc6af104e10) {
  %0 = "arith.constant"() {value = 1 : i32} : () -> i32

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fc6af104ea0) {
  %1 = "arith.constant"() {value = 16 : i32} : () -> i32

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fc6af104f50) {
  %2 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x7fc6af1050a0) {
  %3 = "llvm.load"(%2) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.index_cast'(0x7fc6af105120) {
  %4 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.index_cast'(0x7fc6af1051a0) {
  %5 = "arith.index_cast"(%4) : (index) -> i64

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fc6af1052e0) {
  %6 = "llvm.getelementptr"(%3, %5) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fc6af1053d0) {
  %7 = "llvm.getelementptr"(%6) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x7fc6af105450) {
  %8 = "llvm.load"(%7) : (!llvm.ptr<i32>) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.cmpi'(0x7fc6af105660) {
  %9 = "arith.cmpi"(%8, %1) {predicate = 5 : i64} : (i32, i32) -> i1

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'scf.if'(0x7fc6af1060b0) {
  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.addressof'(0x7fc6af105a20) {
  %24 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fc6af105ca0) {
  %25 = "llvm.getelementptr"(%24) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x7fc6af105e80) {
  %26 = "llvm.call"(%25, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.call'(0x7fc6af106040) {
  "func.call"(%0) {callee = @exit} : (i32) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'scf.yield'(0x7fc6af105740) {
  "scf.yield"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fc6af105a70) {
  %10 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x7fc6af104bc0) {
  %11 = "llvm.load"(%10) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.index_cast'(0x7fc6af106160) {
  %12 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.index_cast'(0x7fc6af1061e0) {
  %13 = "arith.index_cast"(%12) : (index) -> i64

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fc6af106300) {
  %14 = "llvm.getelementptr"(%11, %13) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fc6af106530) {
  %15 = "llvm.getelementptr"(%14) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fc6af1066e0) {
  %16 = "llvm.getelementptr"(%15) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fc6af1067c0) {
  %17 = "llvm.getelementptr"(%14) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x7fc6af106840) {
  %18 = "llvm.load"(%17) : (!llvm.ptr<i32>) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.addi'(0x7fc6af106a50) {
  %19 = "arith.addi"(%18, %0) : (i32, i32) -> i32

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x7fc6af106b60) {
  "llvm.store"(%19, %17) : (i32, !llvm.ptr<i32>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.index_cast'(0x7fc6af106c00) {
  %20 = "arith.index_cast"(%18) : (i32) -> index

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.index_cast'(0x7fc6af1054d0) {
  %21 = "arith.index_cast"(%20) : (index) -> i64

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fc6af1055a0) {
  %22 = "llvm.getelementptr"(%16, %21) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.call'(0x7fc6af1068f0) {
  %23 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.call -> ()' {
Trying to match "mlir::(anonymous namespace)::FuncCallOpDisagg"
    ** Insert  : 'func.call'(0x7fc6af404460)
    ** Replace : 'func.call'(0x7fc6af1068f0)
"mlir::(anonymous namespace)::FuncCallOpDisagg" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func.call'(0x7fc6af404460) {
      %23 = "func.call"(%arg2, %arg3) {callee = @new_graph_node} : (i32, f64) -> !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
'llvm.getelementptr' op using value defined outside the region
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() ({
^bb0(%arg0: !rmem.rmref<!llvm.ptr<!llvm.struct<(!rmem.rmref<!llvm.ptr<!llvm.struct<(!llvm.array<16 x !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>>, i32)>>>, i32)>>>, %arg1: i32, %arg2: i32, %arg3: f64):
  %0 = "arith.constant"() {value = 1 : i32} : () -> i32
  %1 = "arith.constant"() {value = 16 : i32} : () -> i32
  %2 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %3 = "llvm.load"(%2) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %4 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %5 = "arith.index_cast"(%4) : (index) -> i64
  %6 = "llvm.getelementptr"(%3, %5) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %7 = "llvm.getelementptr"(%6) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %8 = "llvm.load"(%7) : (!llvm.ptr<i32>) -> i32
  %9 = "arith.cmpi"(%8, %1) {predicate = 5 : i64} : (i32, i32) -> i1
  "scf.if"(%9) ({
    %25 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
    %26 = "llvm.getelementptr"(%25) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
    %27 = "llvm.call"(%26, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
    "func.call"(%0) {callee = @exit} : (i32) -> ()
    "scf.yield"() : () -> ()
  }, {
  }) : (i1) -> ()
  %10 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %11 = "llvm.load"(%10) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %12 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %13 = "arith.index_cast"(%12) : (index) -> i64
  %14 = "llvm.getelementptr"(%11, %13) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %15 = "llvm.getelementptr"(%14) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
  %16 = "llvm.getelementptr"(%15) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %17 = "llvm.getelementptr"(%14) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %18 = "llvm.load"(%17) : (!llvm.ptr<i32>) -> i32
  %19 = "arith.addi"(%18, %0) : (i32, i32) -> i32
  "llvm.store"(%19, %17) : (i32, !llvm.ptr<i32>) -> ()
  %20 = "arith.index_cast"(%18) : (i32) -> index
  %21 = "arith.index_cast"(%20) : (index) -> i64
  %22 = "llvm.getelementptr"(%16, %21) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %23 = "func.call"(%arg2, %arg3) {callee = @new_graph_node} : (i32, f64) -> !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>
  %24 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
  "llvm.store"(%24, %22) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
  "func.return"() : () -> ()
}) {function_type = (!rmem.rmref<!llvm.ptr<!llvm.struct<(!rmem.rmref<!llvm.ptr<!llvm.struct<(!llvm.array<16 x !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>>, i32)>>>, i32)>>>, i32, i32, f64) -> (), sym_name = "add_edge"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x7fc6af1069b0) {
  "llvm.store"(%24, %22) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.return'(0x7fc6af107290) {
  "func.return"() : () -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.func'(0x7fc6af104ee0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.func'(0x7fc6af104b50) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.func -> ()' {
Trying to match "mlir::(anonymous namespace)::FuncOpDisagg"
    ** Insert  : 'func.func'(0x7fc6af204a00)
    ** Erase   : 'func.func'(0x7fc6af104b50)
"mlir::(anonymous namespace)::FuncOpDisagg" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func.func'(0x7fc6af204a00) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: builtin.module
'func.func' op symbol declaration cannot have public visibility
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"builtin.module"() ({
  "llvm.func"() ({
  }) {function_type = !llvm.func<i32 (ptr<i8>, ...)>, linkage = #llvm.linkage<external>, sym_name = "printf"} : () -> ()
  "llvm.mlir.global"() ({
  }) {addr_space = 0 : i32, constant, global_type = !llvm.array<33 x i8>, linkage = #llvm.linkage<internal>, sym_name = "str0", unnamed_addr = 0 : i64, value = "Too many neighbours for node %d\0A\00"} : () -> ()
  "llvm.func"() ({
  }) {function_type = !llvm.func<ptr<i8> (i64)>, linkage = #llvm.linkage<external>, sym_name = "malloc"} : () -> ()
  "func.func"() ({
  ^bb0(%arg0: i32, %arg1: !rmem.rmref<!llvm.ptr<!rmem.rmref<!llvm.ptr<i8>>>>):
    %0 = "arith.constant"() {value = 2000000 : index} : () -> index
    %1 = "arith.constant"() {value = 0 : index} : () -> index
    %2 = "arith.constant"() {value = 1 : index} : () -> index
    %3 = "arith.constant"() {value = 16 : i64} : () -> i64
    %4 = "arith.constant"() {value = 272000000 : i64} : () -> i64
    %5 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
    %6 = "arith.constant"() {value = 1 : i32} : () -> i32
    %7 = "arith.constant"() {value = 0 : i32} : () -> i32
    %8 = "llvm.call"(%3) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %9 = "llvm.bitcast"(%8) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
    %10 = "builtin.unrealized_conversion_cast"(%9) : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !rmem.rmref<!llvm.ptr<!llvm.struct<(!rmem.rmref<!llvm.ptr<!llvm.struct<(!llvm.array<16 x !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>>, i32)>>>, i32)>>>
    %11 = "llvm.getelementptr"(%9) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %12 = "llvm.call"(%4) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %13 = "llvm.bitcast"(%12) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    "llvm.store"(%13, %11) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
    "scf.for"(%1, %0, %2) ({
    ^bb0(%arg2: index):
      %14 = "llvm.getelementptr"(%9) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
      %15 = "llvm.load"(%14) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
      %16 = "arith.index_cast"(%arg2) : (index) -> i64
      %17 = "llvm.getelementptr"(%15, %16) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
      %18 = "llvm.getelementptr"(%17) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
      "llvm.store"(%7, %18) : (i32, !llvm.ptr<i32>) -> ()
      "scf.yield"() : () -> ()
    }) : (index, index, index) -> ()
    "func.call"(%10, %7, %6, %5) {callee = @add_edge} : (!rmem.rmref<!llvm.ptr<!llvm.struct<(!rmem.rmref<!llvm.ptr<!llvm.struct<(!llvm.array<16 x !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>>, i32)>>>, i32)>>>, i32, i32, f64) -> ()
    "func.call"(%9, %7, %6, %5) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
    "func.return"(%7) : (i32) -> ()
  }) {function_type = (i32, !rmem.rmref<!llvm.ptr<!rmem.rmref<!llvm.ptr<i8>>>>) -> i32, sym_name = "main"} : () -> ()
  "func.func"() ({
  }) {function_type = (i32, !llvm.ptr<ptr<i8>>) -> i32, llvm.linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()
  "func.func"() ({
  ^bb0(%arg0: !rmem.rmref<!llvm.ptr<!llvm.struct<(!rmem.rmref<!llvm.ptr<!llvm.struct<(!llvm.array<16 x !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>>, i32)>>>, i32)>>>, %arg1: i32, %arg2: i32, %arg3: f64):
    %0 = "arith.constant"() {value = 1 : i32} : () -> i32
    %1 = "arith.constant"() {value = 16 : i32} : () -> i32
    %2 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %3 = "llvm.load"(%2) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %4 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
    %5 = "arith.index_cast"(%4) : (index) -> i64
    %6 = "llvm.getelementptr"(%3, %5) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %7 = "llvm.getelementptr"(%6) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %8 = "llvm.load"(%7) : (!llvm.ptr<i32>) -> i32
    %9 = "arith.cmpi"(%8, %1) {predicate = 5 : i64} : (i32, i32) -> i1
    "scf.if"(%9) ({
      %25 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
      %26 = "llvm.getelementptr"(%25) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
      %27 = "llvm.call"(%26, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
      "func.call"(%0) {callee = @exit} : (i32) -> ()
      "scf.yield"() : () -> ()
    }, {
    }) : (i1) -> ()
    %10 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %11 = "llvm.load"(%10) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %12 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
    %13 = "arith.index_cast"(%12) : (index) -> i64
    %14 = "llvm.getelementptr"(%11, %13) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %15 = "llvm.getelementptr"(%14) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
    %16 = "llvm.getelementptr"(%15) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %17 = "llvm.getelementptr"(%14) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %18 = "llvm.load"(%17) : (!llvm.ptr<i32>) -> i32
    %19 = "arith.addi"(%18, %0) : (i32, i32) -> i32
    "llvm.store"(%19, %17) : (i32, !llvm.ptr<i32>) -> ()
    %20 = "arith.index_cast"(%18) : (i32) -> index
    %21 = "arith.index_cast"(%20) : (index) -> i64
    %22 = "llvm.getelementptr"(%16, %21) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %23 = "func.call"(%arg2, %arg3) {callee = @new_graph_node} : (i32, f64) -> !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>
    %24 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
    "llvm.store"(%24, %22) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
    "func.return"() : () -> ()
  }) {function_type = (!rmem.rmref<!llvm.ptr<!llvm.struct<(!rmem.rmref<!llvm.ptr<!llvm.struct<(!llvm.array<16 x !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>>, i32)>>>, i32)>>>, i32, i32, f64) -> (), sym_name = "add_edge"} : () -> ()
  "func.func"() ({
  }) {function_type = (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> (), llvm.linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()
  "func.func"() ({
  }) {function_type = (i32) -> (), llvm.linkage = #llvm.linkage<external>, sym_name = "exit", sym_visibility = "private"} : () -> ()
  "func.func"() ({
  ^bb0(%arg0: i32, %arg1: f64):
    %0 = "arith.constant"() {value = 16 : i64} : () -> i64
    %1 = "llvm.call"(%0) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %2 = "llvm.bitcast"(%1) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(f64, i32)>>
    %3 = "llvm.getelementptr"(%2) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(<<UNKNOWN SSA VALUE>>, %3) : (i32, !llvm.ptr<i32>) -> ()
    %4 = "llvm.getelementptr"(%2) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<f64>
    "llvm.store"(<<UNKNOWN SSA VALUE>>, %4) : (f64, !llvm.ptr<f64>) -> ()
    "func.return"(%2) : (!llvm.ptr<struct<(f64, i32)>>) -> ()
  }) {function_type = (i32, f64) -> !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>, sym_name = "new_graph_node"} : () -> ()
  "func.func"() ({
  }) {function_type = (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>, llvm.linkage = #llvm.linkage<external>, sym_name = "new_graph_node"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fc6af1063a0) {
  %0 = "arith.constant"() {value = 16 : i64} : () -> i64

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x7fc6af106af0) {
  %1 = "llvm.call"(%0) {callee = @malloc} : (i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x7fc6af105af0) {
  %2 = "llvm.bitcast"(%1) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(f64, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fc6af106260) {
  %3 = "llvm.getelementptr"(%2) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<i32>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x7fc6af104990) {
  "llvm.store"(<<UNKNOWN SSA VALUE>>, %3) : (i32, !llvm.ptr<i32>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fc6af106f90) {
  %4 = "llvm.getelementptr"(%2) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<f64>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x7fc6af107000) {
  "llvm.store"(<<UNKNOWN SSA VALUE>>, %4) : (f64, !llvm.ptr<f64>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.return'(0x7fc6af107090) {
  "func.return"(%2) : (!llvm.ptr<struct<(f64, i32)>>) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.return -> ()' {
Trying to match "mlir::(anonymous namespace)::FuncReturnOpDisagg"
    ** Insert  : 'func.return'(0x7fc6af00c510)
    ** Replace : 'func.return'(0x7fc6af107090)
"mlir::(anonymous namespace)::FuncReturnOpDisagg" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func.return'(0x7fc6af00c510) {
      "func.return"(%3) : (!rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: func.func
'func.return' op must be the last operation in the parent block
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() ({
^bb0(%arg0: i32, %arg1: f64):
  %0 = "arith.constant"() {value = 16 : i64} : () -> i64
  %1 = "llvm.call"(%0) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %2 = "llvm.bitcast"(%1) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(f64, i32)>>
  %3 = "builtin.unrealized_conversion_cast"(%2) : (!llvm.ptr<struct<(f64, i32)>>) -> !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>
  %4 = "llvm.getelementptr"(%2) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<i32>
  "llvm.store"(<<UNKNOWN SSA VALUE>>, %4) : (i32, !llvm.ptr<i32>) -> ()
  %5 = "llvm.getelementptr"(%2) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<f64>
  "llvm.store"(<<UNKNOWN SSA VALUE>>, %5) : (f64, !llvm.ptr<f64>) -> ()
  "func.return"(%3) : (!rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>) -> ()
  "func.return"(%2) : (!llvm.ptr<struct<(f64, i32)>>) -> ()
}) {function_type = (i32, f64) -> !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>, sym_name = "new_graph_node"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//
** Insert  : 'rmem.virtualize'(0x7fc6af304970)
** Insert  : 'rmem.virtualize'(0x7fc6af304a60)
** Insert  : 'rmem.materialize'(0x7fc6af3044d0)
** Insert  : 'rmem.materialize'(0x7fc6af304ae0)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::PreservedAnalyses::AllAnalysesType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::rmem::RemoteMemRefType>::Impl<Empty>)
mlir-asm-printer: Verifying operation: builtin.module
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  llvm.func @printf(!llvm.ptr<i8>, ...) -> i32
  llvm.mlir.global internal constant @str0("Too many neighbours for node %d\0A\00") {addr_space = 0 : i32}
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  func.func @main(%arg0: i32, %arg1: !rmem.rmref<!llvm.ptr<!rmem.rmref<!llvm.ptr<i8>>>>) -> i32 {
    %c2000000 = arith.constant 2000000 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c16_i64 = arith.constant 16 : i64
    %c272000000_i64 = arith.constant 272000000 : i64
    %cst = arith.constant 5.000000e-01 : f64
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %0 = llvm.call @malloc(%c16_i64) : (i64) -> !llvm.ptr<i8>
    %1 = llvm.bitcast %0 : !llvm.ptr<i8> to !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
    %2 = rmem.virtualize(%1) : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !rmem.rmref<!llvm.ptr<!llvm.struct<(!rmem.rmref<!llvm.ptr<!llvm.struct<(!llvm.array<16 x !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>>, i32)>>>, i32)>>>
    %3 = llvm.getelementptr %1[0, 0] : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %4 = llvm.call @malloc(%c272000000_i64) : (i64) -> !llvm.ptr<i8>
    %5 = llvm.bitcast %4 : !llvm.ptr<i8> to !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    llvm.store %5, %3 : !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    scf.for %arg2 = %c0 to %c2000000 step %c1 {
      %6 = llvm.getelementptr %1[0, 0] : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
      %7 = llvm.load %6 : !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
      %8 = arith.index_cast %arg2 : index to i64
      %9 = llvm.getelementptr %7[%8] : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
      %10 = llvm.getelementptr %9[0, 1] : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
      llvm.store %c0_i32, %10 : !llvm.ptr<i32>
    }
    call @add_edge(%2, %c0_i32, %c1_i32, %cst) : (!rmem.rmref<!llvm.ptr<!llvm.struct<(!rmem.rmref<!llvm.ptr<!llvm.struct<(!llvm.array<16 x !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>>, i32)>>>, i32)>>>, i32, i32, f64) -> ()
    return %c0_i32 : i32
  }
  func.func @add_edge(%arg0: !rmem.rmref<!llvm.ptr<!llvm.struct<(!rmem.rmref<!llvm.ptr<!llvm.struct<(!llvm.array<16 x !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>>, i32)>>>, i32)>>>, %arg1: i32, %arg2: i32, %arg3: f64) {
    %0 = rmem.materialize %arg0 : (!rmem.rmref<!llvm.ptr<!llvm.struct<(!rmem.rmref<!llvm.ptr<!llvm.struct<(!llvm.array<16 x !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>>, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
    %c1_i32 = arith.constant 1 : i32
    %c16_i32 = arith.constant 16 : i32
    %1 = llvm.getelementptr %0[0, 0] : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %2 = llvm.load %1 : !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %3 = arith.index_cast %arg1 : i32 to index
    %4 = arith.index_cast %3 : index to i64
    %5 = llvm.getelementptr %2[%4] : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %6 = llvm.getelementptr %5[0, 1] : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %7 = llvm.load %6 : !llvm.ptr<i32>
    %8 = arith.cmpi sge, %7, %c16_i32 : i32
    scf.if %8 {
      %24 = llvm.mlir.addressof @str0 : !llvm.ptr<array<33 x i8>>
      %25 = llvm.getelementptr %24[0, 0] : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
      %26 = llvm.call @printf(%25, %arg1) : (!llvm.ptr<i8>, i32) -> i32
      func.call @exit(%c1_i32) : (i32) -> ()
    }
    %9 = llvm.getelementptr %0[0, 0] : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %10 = llvm.load %9 : !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %11 = arith.index_cast %arg1 : i32 to index
    %12 = arith.index_cast %11 : index to i64
    %13 = llvm.getelementptr %10[%12] : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %14 = llvm.getelementptr %13[0, 0] : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
    %15 = llvm.getelementptr %14[0, 0] : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %16 = llvm.getelementptr %13[0, 1] : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %17 = llvm.load %16 : !llvm.ptr<i32>
    %18 = arith.addi %17, %c1_i32 : i32
    llvm.store %18, %16 : !llvm.ptr<i32>
    %19 = arith.index_cast %17 : i32 to index
    %20 = arith.index_cast %19 : index to i64
    %21 = llvm.getelementptr %15[%20] : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %22 = call @new_graph_node(%arg2, %arg3) : (i32, f64) -> !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>
    %23 = rmem.materialize %22 : (!rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>) -> !llvm.ptr<struct<(f64, i32)>>
    llvm.store %23, %21 : !llvm.ptr<ptr<struct<(f64, i32)>>>
    return
  }
  func.func private @exit(i32) attributes {llvm.linkage = #llvm.linkage<external>}
  func.func @new_graph_node(%arg0: i32, %arg1: f64) -> !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>> {
    %c16_i64 = arith.constant 16 : i64
    %0 = llvm.call @malloc(%c16_i64) : (i64) -> !llvm.ptr<i8>
    %1 = llvm.bitcast %0 : !llvm.ptr<i8> to !llvm.ptr<struct<(f64, i32)>>
    %2 = rmem.virtualize(%1) : (!llvm.ptr<struct<(f64, i32)>>) -> !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>
    %3 = llvm.getelementptr %1[0, 1] : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<i32>
    llvm.store %arg0, %3 : !llvm.ptr<i32>
    %4 = llvm.getelementptr %1[0, 0] : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<f64>
    llvm.store %arg1, %4 : !llvm.ptr<f64>
    return %2 : !rmem.rmref<!llvm.ptr<struct<(f64, i32)>>>
  }
}

