Args: mlir-opt --convert-func-to-llvm ../example/from_cg/test.mlir -debug 
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubElementTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemRefLayoutAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubElementAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ElementsAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineBinaryOpExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineConstantExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineDimExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineMapStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::IntegerSetStorage)
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DebugActionManager::GenericHandler)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneRegion<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroSuccessors<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoRegionArguments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlock<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OpInvariants<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AffineScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsIsolatedFromAbove<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SymbolTable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasOnlyGraphRegion<Empty>)
Load new dialect in Context dlti
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutEntryAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutEntryInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutSpecAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutSpecInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutDialectInterface)
Load new dialect in Context llvm
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMVoidType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMPPCFP128Type)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMX86MMXType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMTokenType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMLabelType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMMetadataType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMFunctionType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMPointerType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMFixedVectorType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMScalableVectorType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMArrayType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMStructType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::FastmathFlagsInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AutomaticAllocationScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlockImplicitTerminator<mlir::LLVM::ReturnOp>::Impl<Empty>)
Load new dialect in Context func
Load new dialect in Context cf
Load new dialect in Context arith
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectInlinerInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferizableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroRegions<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneResult<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ConstantLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::FastmathFlagsInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneOperand<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NOperands<2>::Impl<Empty>)
Load new dialect in Context scf
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchTerminatorOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LoopLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AtLeastNOperands<3>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LoopLikeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasRecursiveSideEffects<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameOperandsAndResultShape<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Elementwise<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Scalarizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Vectorizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Tensorizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp, mlir::scf::ForOp, mlir::scf::IfOp, mlir::scf::ParallelOp, mlir::scf::WhileOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ReturnLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::MemRefsNormalizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameTypeOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NRegions<2>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::LLVM::LLVMPointerType>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsCommutative<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameOperandsAndResultType<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutAnalysis)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutOpInterface)

//===-------------------------------------------===//
Legalizing operation : 'builtin.module'(0x7fd610b07840) {
  * Fold {
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectFoldInterface)
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x7fd61081bc50) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.global'(0x7fd60ff0ddf0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x7fd60ff0c570) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.func'(0x7fd61081e0e0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.func -> ()' {
Trying to match "(anonymous namespace)::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x7fd610c051d0)
    ** Erase   : 'func.func'(0x7fd61081e0e0)
"(anonymous namespace)::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x7fd610c051d0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: builtin.module
'func.return' op expects parent op 'func.func'
'func.func' op symbol declaration cannot have public visibility
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"builtin.module"() ({
  "llvm.func"() ({
  }) {function_type = !llvm.func<i32 (ptr<i8>, ...)>, linkage = #llvm.linkage<external>, sym_name = "printf"} : () -> ()
  "llvm.mlir.global"() ({
  }) {addr_space = 0 : i32, constant, global_type = !llvm.array<33 x i8>, linkage = #llvm.linkage<internal>, sym_name = "str0", unnamed_addr = 0 : i64, value = "Too many neighbours for node %d\0A\00"} : () -> ()
  "llvm.func"() ({
  }) {function_type = !llvm.func<ptr<i8> (i64)>, linkage = #llvm.linkage<external>, sym_name = "malloc"} : () -> ()
  "llvm.func"() ({
  ^bb0(%arg0: i32, %arg1: !llvm.ptr<ptr<i8>>):
    %0 = "arith.constant"() {value = 2000000 : index} : () -> index
    %1 = "arith.constant"() {value = 0 : index} : () -> index
    %2 = "arith.constant"() {value = 1 : index} : () -> index
    %3 = "arith.constant"() {value = 16 : i64} : () -> i64
    %4 = "arith.constant"() {value = 272000000 : i64} : () -> i64
    %5 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
    %6 = "arith.constant"() {value = 1 : i32} : () -> i32
    %7 = "arith.constant"() {value = 0 : i32} : () -> i32
    %8 = "llvm.call"(%3) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %9 = "llvm.bitcast"(%8) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
    %10 = "llvm.getelementptr"(%9) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %11 = "llvm.call"(%4) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %12 = "llvm.bitcast"(%11) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    "llvm.store"(%12, %10) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
    "scf.for"(%1, %0, %2) ({
    ^bb0(%arg2: index):
      %13 = "llvm.getelementptr"(%9) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
      %14 = "llvm.load"(%13) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
      %15 = "arith.index_cast"(%arg2) : (index) -> i64
      %16 = "llvm.getelementptr"(%14, %15) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
      %17 = "llvm.getelementptr"(%16) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
      "llvm.store"(%7, %17) : (i32, !llvm.ptr<i32>) -> ()
      "scf.yield"() : () -> ()
    }) : (index, index, index) -> ()
    "func.call"(%9, %7, %6, %5) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
    "func.return"(%7) : (i32) -> ()
  }) {function_type = !llvm.func<i32 (i32, ptr<ptr<i8>>)>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()
  "func.func"() ({
  }) {function_type = (i32, !llvm.ptr<ptr<i8>>) -> i32, llvm.linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()
  "func.func"() ({
  ^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
    %0 = "arith.constant"() {value = 1 : i32} : () -> i32
    %1 = "arith.constant"() {value = 16 : i32} : () -> i32
    %2 = "llvm.getelementptr"(%arg0) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %3 = "llvm.load"(%2) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %4 = "arith.index_cast"(%arg1) : (i32) -> index
    %5 = "arith.index_cast"(%4) : (index) -> i64
    %6 = "llvm.getelementptr"(%3, %5) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %7 = "llvm.getelementptr"(%6) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %8 = "llvm.load"(%7) : (!llvm.ptr<i32>) -> i32
    %9 = "arith.cmpi"(%8, %1) {predicate = 5 : i64} : (i32, i32) -> i1
    "scf.if"(%9) ({
      %24 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
      %25 = "llvm.getelementptr"(%24) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
      %26 = "llvm.call"(%25, %arg1) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
      "func.call"(%0) {callee = @exit} : (i32) -> ()
      "scf.yield"() : () -> ()
    }, {
    }) : (i1) -> ()
    %10 = "llvm.getelementptr"(%arg0) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %11 = "llvm.load"(%10) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %12 = "arith.index_cast"(%arg1) : (i32) -> index
    %13 = "arith.index_cast"(%12) : (index) -> i64
    %14 = "llvm.getelementptr"(%11, %13) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %15 = "llvm.getelementptr"(%14) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
    %16 = "llvm.getelementptr"(%15) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %17 = "llvm.getelementptr"(%14) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %18 = "llvm.load"(%17) : (!llvm.ptr<i32>) -> i32
    %19 = "arith.addi"(%18, %0) : (i32, i32) -> i32
    "llvm.store"(%19, %17) : (i32, !llvm.ptr<i32>) -> ()
    %20 = "arith.index_cast"(%18) : (i32) -> index
    %21 = "arith.index_cast"(%20) : (index) -> i64
    %22 = "llvm.getelementptr"(%16, %21) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %23 = "func.call"(%arg2, %arg3) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
    "llvm.store"(%23, %22) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
    "func.return"() : () -> ()
  }) {function_type = (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> (), llvm.linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()
  "func.func"() ({
  }) {function_type = (i32) -> (), llvm.linkage = #llvm.linkage<external>, sym_name = "exit", sym_visibility = "private"} : () -> ()
  "func.func"() ({
  ^bb0(%arg0: i32, %arg1: f64):
    %0 = "arith.constant"() {value = 16 : i64} : () -> i64
    %1 = "llvm.call"(%0) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %2 = "llvm.bitcast"(%1) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(f64, i32)>>
    %3 = "llvm.getelementptr"(%2) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(%arg0, %3) : (i32, !llvm.ptr<i32>) -> ()
    %4 = "llvm.getelementptr"(%2) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<f64>
    "llvm.store"(%arg1, %4) : (f64, !llvm.ptr<f64>) -> ()
    "func.return"(%2) : (!llvm.ptr<struct<(f64, i32)>>) -> ()
  }) {function_type = (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>, llvm.linkage = #llvm.linkage<external>, sym_name = "new_graph_node"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fd60ff0e730) {
  %0 = "arith.constant"() {value = 2000000 : index} : () -> index

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.constant'(0x7fd610b07d90)
    ** Replace : 'arith.constant'(0x7fd60ff0e730)
"(anonymous namespace)::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x7fd610b07d90) {
      %0 = "llvm.mlir.constant"() {value = 2000000 : index} : () -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: i32, %arg1: !llvm.ptr<ptr<i8>>):
  %0 = "llvm.mlir.constant"() {value = 2000000 : index} : () -> i64
  %1 = "arith.constant"() {value = 2000000 : index} : () -> index
  %2 = "arith.constant"() {value = 0 : index} : () -> index
  %3 = "arith.constant"() {value = 1 : index} : () -> index
  %4 = "arith.constant"() {value = 16 : i64} : () -> i64
  %5 = "arith.constant"() {value = 272000000 : i64} : () -> i64
  %6 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
  %7 = "arith.constant"() {value = 1 : i32} : () -> i32
  %8 = "arith.constant"() {value = 0 : i32} : () -> i32
  %9 = "llvm.call"(%4) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %10 = "llvm.bitcast"(%9) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
  %11 = "llvm.getelementptr"(%10) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %12 = "llvm.call"(%5) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %13 = "llvm.bitcast"(%12) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  "llvm.store"(%13, %11) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
  "scf.for"(%2, %1, %3) ({
  ^bb0(%arg2: index):
    %14 = "llvm.getelementptr"(%10) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %15 = "llvm.load"(%14) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %16 = "arith.index_cast"(%arg2) : (index) -> i64
    %17 = "llvm.getelementptr"(%15, %16) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %18 = "llvm.getelementptr"(%17) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(%8, %18) : (i32, !llvm.ptr<i32>) -> ()
    "scf.yield"() : () -> ()
  }) : (index, index, index) -> ()
  "func.call"(%10, %8, %7, %6) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
  "func.return"(%8) : (i32) -> ()
}) {function_type = !llvm.func<i32 (i32, ptr<ptr<i8>>)>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fd60ff0e830) {
  %2 = "arith.constant"() {value = 0 : index} : () -> index

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.constant'(0x7fd61081e8e0)
    ** Replace : 'arith.constant'(0x7fd60ff0e830)
"(anonymous namespace)::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x7fd61081e8e0) {
      %2 = "llvm.mlir.constant"() {value = 0 : index} : () -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: i32, %arg1: !llvm.ptr<ptr<i8>>):
  %0 = "llvm.mlir.constant"() {value = 2000000 : index} : () -> i64
  %1 = "arith.constant"() {value = 2000000 : index} : () -> index
  %2 = "llvm.mlir.constant"() {value = 0 : index} : () -> i64
  %3 = "arith.constant"() {value = 0 : index} : () -> index
  %4 = "arith.constant"() {value = 1 : index} : () -> index
  %5 = "arith.constant"() {value = 16 : i64} : () -> i64
  %6 = "arith.constant"() {value = 272000000 : i64} : () -> i64
  %7 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
  %8 = "arith.constant"() {value = 1 : i32} : () -> i32
  %9 = "arith.constant"() {value = 0 : i32} : () -> i32
  %10 = "llvm.call"(%5) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %11 = "llvm.bitcast"(%10) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
  %12 = "llvm.getelementptr"(%11) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %13 = "llvm.call"(%6) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %14 = "llvm.bitcast"(%13) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  "llvm.store"(%14, %12) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
  "scf.for"(%3, %1, %4) ({
  ^bb0(%arg2: index):
    %15 = "llvm.getelementptr"(%11) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %16 = "llvm.load"(%15) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %17 = "arith.index_cast"(%arg2) : (index) -> i64
    %18 = "llvm.getelementptr"(%16, %17) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %19 = "llvm.getelementptr"(%18) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(%9, %19) : (i32, !llvm.ptr<i32>) -> ()
    "scf.yield"() : () -> ()
  }) : (index, index, index) -> ()
  "func.call"(%11, %9, %8, %7) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
  "func.return"(%9) : (i32) -> ()
}) {function_type = !llvm.func<i32 (i32, ptr<ptr<i8>>)>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fd60ff0e9f0) {
  %4 = "arith.constant"() {value = 1 : index} : () -> index

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.constant'(0x7fd610a1efa0)
    ** Replace : 'arith.constant'(0x7fd60ff0e9f0)
"(anonymous namespace)::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x7fd610a1efa0) {
      %4 = "llvm.mlir.constant"() {value = 1 : index} : () -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: i32, %arg1: !llvm.ptr<ptr<i8>>):
  %0 = "llvm.mlir.constant"() {value = 2000000 : index} : () -> i64
  %1 = "arith.constant"() {value = 2000000 : index} : () -> index
  %2 = "llvm.mlir.constant"() {value = 0 : index} : () -> i64
  %3 = "arith.constant"() {value = 0 : index} : () -> index
  %4 = "llvm.mlir.constant"() {value = 1 : index} : () -> i64
  %5 = "arith.constant"() {value = 1 : index} : () -> index
  %6 = "arith.constant"() {value = 16 : i64} : () -> i64
  %7 = "arith.constant"() {value = 272000000 : i64} : () -> i64
  %8 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
  %9 = "arith.constant"() {value = 1 : i32} : () -> i32
  %10 = "arith.constant"() {value = 0 : i32} : () -> i32
  %11 = "llvm.call"(%6) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %12 = "llvm.bitcast"(%11) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
  %13 = "llvm.getelementptr"(%12) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %14 = "llvm.call"(%7) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %15 = "llvm.bitcast"(%14) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  "llvm.store"(%15, %13) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
  "scf.for"(%3, %1, %5) ({
  ^bb0(%arg2: index):
    %16 = "llvm.getelementptr"(%12) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %17 = "llvm.load"(%16) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %18 = "arith.index_cast"(%arg2) : (index) -> i64
    %19 = "llvm.getelementptr"(%17, %18) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %20 = "llvm.getelementptr"(%19) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(%10, %20) : (i32, !llvm.ptr<i32>) -> ()
    "scf.yield"() : () -> ()
  }) : (index, index, index) -> ()
  "func.call"(%12, %10, %9, %8) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
  "func.return"(%10) : (i32) -> ()
}) {function_type = !llvm.func<i32 (i32, ptr<ptr<i8>>)>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fd60ff0ebb0) {
  %6 = "arith.constant"() {value = 16 : i64} : () -> i64

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.constant'(0x7fd61081f120)
    ** Replace : 'arith.constant'(0x7fd60ff0ebb0)
"(anonymous namespace)::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x7fd61081f120) {
      %6 = "llvm.mlir.constant"() {value = 16 : i64} : () -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: i32, %arg1: !llvm.ptr<ptr<i8>>):
  %0 = "llvm.mlir.constant"() {value = 2000000 : index} : () -> i64
  %1 = "arith.constant"() {value = 2000000 : index} : () -> index
  %2 = "llvm.mlir.constant"() {value = 0 : index} : () -> i64
  %3 = "arith.constant"() {value = 0 : index} : () -> index
  %4 = "llvm.mlir.constant"() {value = 1 : index} : () -> i64
  %5 = "arith.constant"() {value = 1 : index} : () -> index
  %6 = "llvm.mlir.constant"() {value = 16 : i64} : () -> i64
  %7 = "arith.constant"() {value = 16 : i64} : () -> i64
  %8 = "arith.constant"() {value = 272000000 : i64} : () -> i64
  %9 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
  %10 = "arith.constant"() {value = 1 : i32} : () -> i32
  %11 = "arith.constant"() {value = 0 : i32} : () -> i32
  %12 = "llvm.call"(%7) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %13 = "llvm.bitcast"(%12) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
  %14 = "llvm.getelementptr"(%13) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %15 = "llvm.call"(%8) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %16 = "llvm.bitcast"(%15) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  "llvm.store"(%16, %14) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
  "scf.for"(%3, %1, %5) ({
  ^bb0(%arg2: index):
    %17 = "llvm.getelementptr"(%13) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %18 = "llvm.load"(%17) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %19 = "arith.index_cast"(%arg2) : (index) -> i64
    %20 = "llvm.getelementptr"(%18, %19) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %21 = "llvm.getelementptr"(%20) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(%11, %21) : (i32, !llvm.ptr<i32>) -> ()
    "scf.yield"() : () -> ()
  }) : (index, index, index) -> ()
  "func.call"(%13, %11, %10, %9) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
  "func.return"(%11) : (i32) -> ()
}) {function_type = !llvm.func<i32 (i32, ptr<ptr<i8>>)>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fd60ff0ed90) {
  %8 = "arith.constant"() {value = 272000000 : i64} : () -> i64

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.constant'(0x7fd61081dd60)
    ** Replace : 'arith.constant'(0x7fd60ff0ed90)
"(anonymous namespace)::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x7fd61081dd60) {
      %8 = "llvm.mlir.constant"() {value = 272000000 : i64} : () -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: i32, %arg1: !llvm.ptr<ptr<i8>>):
  %0 = "llvm.mlir.constant"() {value = 2000000 : index} : () -> i64
  %1 = "arith.constant"() {value = 2000000 : index} : () -> index
  %2 = "llvm.mlir.constant"() {value = 0 : index} : () -> i64
  %3 = "arith.constant"() {value = 0 : index} : () -> index
  %4 = "llvm.mlir.constant"() {value = 1 : index} : () -> i64
  %5 = "arith.constant"() {value = 1 : index} : () -> index
  %6 = "llvm.mlir.constant"() {value = 16 : i64} : () -> i64
  %7 = "arith.constant"() {value = 16 : i64} : () -> i64
  %8 = "llvm.mlir.constant"() {value = 272000000 : i64} : () -> i64
  %9 = "arith.constant"() {value = 272000000 : i64} : () -> i64
  %10 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
  %11 = "arith.constant"() {value = 1 : i32} : () -> i32
  %12 = "arith.constant"() {value = 0 : i32} : () -> i32
  %13 = "llvm.call"(%7) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %14 = "llvm.bitcast"(%13) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
  %15 = "llvm.getelementptr"(%14) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %16 = "llvm.call"(%9) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %17 = "llvm.bitcast"(%16) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  "llvm.store"(%17, %15) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
  "scf.for"(%3, %1, %5) ({
  ^bb0(%arg2: index):
    %18 = "llvm.getelementptr"(%14) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %19 = "llvm.load"(%18) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %20 = "arith.index_cast"(%arg2) : (index) -> i64
    %21 = "llvm.getelementptr"(%19, %20) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %22 = "llvm.getelementptr"(%21) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(%12, %22) : (i32, !llvm.ptr<i32>) -> ()
    "scf.yield"() : () -> ()
  }) : (index, index, index) -> ()
  "func.call"(%14, %12, %11, %10) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
  "func.return"(%12) : (i32) -> ()
}) {function_type = !llvm.func<i32 (i32, ptr<ptr<i8>>)>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fd61081d460) {
  %10 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.constant'(0x7fd610a21140)
    ** Replace : 'arith.constant'(0x7fd61081d460)
"(anonymous namespace)::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x7fd610a21140) {
      %10 = "llvm.mlir.constant"() {value = 5.000000e-01 : f64} : () -> f64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: i32, %arg1: !llvm.ptr<ptr<i8>>):
  %0 = "llvm.mlir.constant"() {value = 2000000 : index} : () -> i64
  %1 = "arith.constant"() {value = 2000000 : index} : () -> index
  %2 = "llvm.mlir.constant"() {value = 0 : index} : () -> i64
  %3 = "arith.constant"() {value = 0 : index} : () -> index
  %4 = "llvm.mlir.constant"() {value = 1 : index} : () -> i64
  %5 = "arith.constant"() {value = 1 : index} : () -> index
  %6 = "llvm.mlir.constant"() {value = 16 : i64} : () -> i64
  %7 = "arith.constant"() {value = 16 : i64} : () -> i64
  %8 = "llvm.mlir.constant"() {value = 272000000 : i64} : () -> i64
  %9 = "arith.constant"() {value = 272000000 : i64} : () -> i64
  %10 = "llvm.mlir.constant"() {value = 5.000000e-01 : f64} : () -> f64
  %11 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
  %12 = "arith.constant"() {value = 1 : i32} : () -> i32
  %13 = "arith.constant"() {value = 0 : i32} : () -> i32
  %14 = "llvm.call"(%7) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %15 = "llvm.bitcast"(%14) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
  %16 = "llvm.getelementptr"(%15) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %17 = "llvm.call"(%9) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %18 = "llvm.bitcast"(%17) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  "llvm.store"(%18, %16) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
  "scf.for"(%3, %1, %5) ({
  ^bb0(%arg2: index):
    %19 = "llvm.getelementptr"(%15) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %20 = "llvm.load"(%19) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %21 = "arith.index_cast"(%arg2) : (index) -> i64
    %22 = "llvm.getelementptr"(%20, %21) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %23 = "llvm.getelementptr"(%22) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(%13, %23) : (i32, !llvm.ptr<i32>) -> ()
    "scf.yield"() : () -> ()
  }) : (index, index, index) -> ()
  "func.call"(%15, %13, %12, %11) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
  "func.return"(%13) : (i32) -> ()
}) {function_type = !llvm.func<i32 (i32, ptr<ptr<i8>>)>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fd61081d660) {
  %12 = "arith.constant"() {value = 1 : i32} : () -> i32

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.constant'(0x7fd60ff0ede0)
    ** Replace : 'arith.constant'(0x7fd61081d660)
"(anonymous namespace)::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x7fd60ff0ede0) {
      %12 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: i32, %arg1: !llvm.ptr<ptr<i8>>):
  %0 = "llvm.mlir.constant"() {value = 2000000 : index} : () -> i64
  %1 = "arith.constant"() {value = 2000000 : index} : () -> index
  %2 = "llvm.mlir.constant"() {value = 0 : index} : () -> i64
  %3 = "arith.constant"() {value = 0 : index} : () -> index
  %4 = "llvm.mlir.constant"() {value = 1 : index} : () -> i64
  %5 = "arith.constant"() {value = 1 : index} : () -> index
  %6 = "llvm.mlir.constant"() {value = 16 : i64} : () -> i64
  %7 = "arith.constant"() {value = 16 : i64} : () -> i64
  %8 = "llvm.mlir.constant"() {value = 272000000 : i64} : () -> i64
  %9 = "arith.constant"() {value = 272000000 : i64} : () -> i64
  %10 = "llvm.mlir.constant"() {value = 5.000000e-01 : f64} : () -> f64
  %11 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
  %12 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %13 = "arith.constant"() {value = 1 : i32} : () -> i32
  %14 = "arith.constant"() {value = 0 : i32} : () -> i32
  %15 = "llvm.call"(%7) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %16 = "llvm.bitcast"(%15) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
  %17 = "llvm.getelementptr"(%16) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %18 = "llvm.call"(%9) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %19 = "llvm.bitcast"(%18) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  "llvm.store"(%19, %17) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
  "scf.for"(%3, %1, %5) ({
  ^bb0(%arg2: index):
    %20 = "llvm.getelementptr"(%16) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %21 = "llvm.load"(%20) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %22 = "arith.index_cast"(%arg2) : (index) -> i64
    %23 = "llvm.getelementptr"(%21, %22) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %24 = "llvm.getelementptr"(%23) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(%14, %24) : (i32, !llvm.ptr<i32>) -> ()
    "scf.yield"() : () -> ()
  }) : (index, index, index) -> ()
  "func.call"(%16, %14, %13, %11) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
  "func.return"(%14) : (i32) -> ()
}) {function_type = !llvm.func<i32 (i32, ptr<ptr<i8>>)>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fd61081d820) {
  %14 = "arith.constant"() {value = 0 : i32} : () -> i32

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.constant'(0x7fd61081f210)
    ** Replace : 'arith.constant'(0x7fd61081d820)
"(anonymous namespace)::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x7fd61081f210) {
      %14 = "llvm.mlir.constant"() {value = 0 : i32} : () -> i32

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: i32, %arg1: !llvm.ptr<ptr<i8>>):
  %0 = "llvm.mlir.constant"() {value = 2000000 : index} : () -> i64
  %1 = "arith.constant"() {value = 2000000 : index} : () -> index
  %2 = "llvm.mlir.constant"() {value = 0 : index} : () -> i64
  %3 = "arith.constant"() {value = 0 : index} : () -> index
  %4 = "llvm.mlir.constant"() {value = 1 : index} : () -> i64
  %5 = "arith.constant"() {value = 1 : index} : () -> index
  %6 = "llvm.mlir.constant"() {value = 16 : i64} : () -> i64
  %7 = "arith.constant"() {value = 16 : i64} : () -> i64
  %8 = "llvm.mlir.constant"() {value = 272000000 : i64} : () -> i64
  %9 = "arith.constant"() {value = 272000000 : i64} : () -> i64
  %10 = "llvm.mlir.constant"() {value = 5.000000e-01 : f64} : () -> f64
  %11 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
  %12 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %13 = "arith.constant"() {value = 1 : i32} : () -> i32
  %14 = "llvm.mlir.constant"() {value = 0 : i32} : () -> i32
  %15 = "arith.constant"() {value = 0 : i32} : () -> i32
  %16 = "llvm.call"(%7) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %17 = "llvm.bitcast"(%16) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
  %18 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %19 = "llvm.call"(%9) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %20 = "llvm.bitcast"(%19) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  "llvm.store"(%20, %18) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
  "scf.for"(%3, %1, %5) ({
  ^bb0(%arg2: index):
    %21 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %22 = "llvm.load"(%21) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %23 = "arith.index_cast"(%arg2) : (index) -> i64
    %24 = "llvm.getelementptr"(%22, %23) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %25 = "llvm.getelementptr"(%24) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(%15, %25) : (i32, !llvm.ptr<i32>) -> ()
    "scf.yield"() : () -> ()
  }) : (index, index, index) -> ()
  "func.call"(%17, %15, %13, %11) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
  "func.return"(%15) : (i32) -> ()
}) {function_type = !llvm.func<i32 (i32, ptr<ptr<i8>>)>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x7fd61081da30) {
  %16 = "llvm.call"(%7) {callee = @malloc} : (i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x7fd610a20540) {
  %17 = "llvm.bitcast"(%16) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fd61081dee0) {
  %18 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x7fd61081e2b0) {
  %19 = "llvm.call"(%9) {callee = @malloc} : (i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x7fd61081e360) {
  %20 = "llvm.bitcast"(%19) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x7fd61081e420) {
  "llvm.store"(%20, %18) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'scf.for'(0x7fd610a21620) {
  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fd610c04b60) {
  %21 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x7fd610c04cb0) {
  %22 = "llvm.load"(%21) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.index_cast'(0x7fd610a210c0) {
  %23 = "arith.index_cast"(%arg2) : (index) -> i64

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOpLowering"
    ** Replace : 'arith.index_cast'(0x7fd610a210c0)
"(anonymous namespace)::IndexCastOpLowering" result 1
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: i32, %arg1: !llvm.ptr<ptr<i8>>):
  %0 = "llvm.mlir.constant"() {value = 2000000 : index} : () -> i64
  %1 = "arith.constant"() {value = 2000000 : index} : () -> index
  %2 = "llvm.mlir.constant"() {value = 0 : index} : () -> i64
  %3 = "arith.constant"() {value = 0 : index} : () -> index
  %4 = "llvm.mlir.constant"() {value = 1 : index} : () -> i64
  %5 = "arith.constant"() {value = 1 : index} : () -> index
  %6 = "llvm.mlir.constant"() {value = 16 : i64} : () -> i64
  %7 = "arith.constant"() {value = 16 : i64} : () -> i64
  %8 = "llvm.mlir.constant"() {value = 272000000 : i64} : () -> i64
  %9 = "arith.constant"() {value = 272000000 : i64} : () -> i64
  %10 = "llvm.mlir.constant"() {value = 5.000000e-01 : f64} : () -> f64
  %11 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
  %12 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %13 = "arith.constant"() {value = 1 : i32} : () -> i32
  %14 = "llvm.mlir.constant"() {value = 0 : i32} : () -> i32
  %15 = "arith.constant"() {value = 0 : i32} : () -> i32
  %16 = "llvm.call"(%7) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %17 = "llvm.bitcast"(%16) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
  %18 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %19 = "llvm.call"(%9) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %20 = "llvm.bitcast"(%19) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  "llvm.store"(%20, %18) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
  "scf.for"(%3, %1, %5) ({
  ^bb0(%arg2: index):
    %21 = "builtin.unrealized_conversion_cast"(%arg2) : (index) -> i64
    %22 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %23 = "llvm.load"(%22) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %24 = "arith.index_cast"(%arg2) : (index) -> i64
    %25 = "llvm.getelementptr"(%23, %24) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %26 = "llvm.getelementptr"(%25) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(%15, %26) : (i32, !llvm.ptr<i32>) -> ()
    "scf.yield"() : () -> ()
  }) : (index, index, index) -> ()
  "func.call"(%17, %15, %13, %11) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
  "func.return"(%15) : (i32) -> ()
}) {function_type = !llvm.func<i32 (i32, ptr<ptr<i8>>)>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fd610a21350) {
  %25 = "llvm.getelementptr"(%23, %24) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fd610a21520) {
  %26 = "llvm.getelementptr"(%25) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x7fd610a21590) {
  "llvm.store"(%15, %26) : (i32, !llvm.ptr<i32>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'scf.yield'(0x7fd610a1fef0) {
  "scf.yield"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.call'(0x7fd61081e5d0) {
  "func.call"(%17, %15, %13, %11) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.call -> ()' {
Trying to match "(anonymous namespace)::CallOpLowering"
    ** Insert  : 'llvm.call'(0x7fd610a21760)
    ** Replace : 'func.call'(0x7fd61081e5d0)
"(anonymous namespace)::CallOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.call'(0x7fd610a21760) {
      "llvm.call"(%17, %14, %12, %10) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'llvm.call' op 'add_edge' does not reference a valid LLVM function
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: i32, %arg1: !llvm.ptr<ptr<i8>>):
  %0 = "llvm.mlir.constant"() {value = 2000000 : index} : () -> i64
  %1 = "arith.constant"() {value = 2000000 : index} : () -> index
  %2 = "llvm.mlir.constant"() {value = 0 : index} : () -> i64
  %3 = "arith.constant"() {value = 0 : index} : () -> index
  %4 = "llvm.mlir.constant"() {value = 1 : index} : () -> i64
  %5 = "arith.constant"() {value = 1 : index} : () -> index
  %6 = "llvm.mlir.constant"() {value = 16 : i64} : () -> i64
  %7 = "arith.constant"() {value = 16 : i64} : () -> i64
  %8 = "llvm.mlir.constant"() {value = 272000000 : i64} : () -> i64
  %9 = "arith.constant"() {value = 272000000 : i64} : () -> i64
  %10 = "llvm.mlir.constant"() {value = 5.000000e-01 : f64} : () -> f64
  %11 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
  %12 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %13 = "arith.constant"() {value = 1 : i32} : () -> i32
  %14 = "llvm.mlir.constant"() {value = 0 : i32} : () -> i32
  %15 = "arith.constant"() {value = 0 : i32} : () -> i32
  %16 = "llvm.call"(%7) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %17 = "llvm.bitcast"(%16) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
  %18 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %19 = "llvm.call"(%9) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %20 = "llvm.bitcast"(%19) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  "llvm.store"(%20, %18) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
  "scf.for"(%3, %1, %5) ({
  ^bb0(%arg2: index):
    %21 = "builtin.unrealized_conversion_cast"(%arg2) : (index) -> i64
    %22 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %23 = "llvm.load"(%22) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %24 = "arith.index_cast"(%arg2) : (index) -> i64
    %25 = "llvm.getelementptr"(%23, %24) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %26 = "llvm.getelementptr"(%25) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(%15, %26) : (i32, !llvm.ptr<i32>) -> ()
    "scf.yield"() : () -> ()
  }) : (index, index, index) -> ()
  "llvm.call"(%17, %14, %12, %10) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
  "func.call"(%17, %15, %13, %11) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
  "func.return"(%15) : (i32) -> ()
}) {function_type = !llvm.func<i32 (i32, ptr<ptr<i8>>)>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.return'(0x7fd61081e6a0) {
  "func.return"(%15) : (i32) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.return -> ()' {
Trying to match "(anonymous namespace)::ReturnOpLowering"
    ** Insert  : 'llvm.return'(0x7fd60ff0f290)
    ** Replace : 'func.return'(0x7fd61081e6a0)
"(anonymous namespace)::ReturnOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.return'(0x7fd60ff0f290) {
      "llvm.return"(%14) : (i32) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'llvm.call' op 'add_edge' does not reference a valid LLVM function
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: i32, %arg1: !llvm.ptr<ptr<i8>>):
  %0 = "llvm.mlir.constant"() {value = 2000000 : index} : () -> i64
  %1 = "arith.constant"() {value = 2000000 : index} : () -> index
  %2 = "llvm.mlir.constant"() {value = 0 : index} : () -> i64
  %3 = "arith.constant"() {value = 0 : index} : () -> index
  %4 = "llvm.mlir.constant"() {value = 1 : index} : () -> i64
  %5 = "arith.constant"() {value = 1 : index} : () -> index
  %6 = "llvm.mlir.constant"() {value = 16 : i64} : () -> i64
  %7 = "arith.constant"() {value = 16 : i64} : () -> i64
  %8 = "llvm.mlir.constant"() {value = 272000000 : i64} : () -> i64
  %9 = "arith.constant"() {value = 272000000 : i64} : () -> i64
  %10 = "llvm.mlir.constant"() {value = 5.000000e-01 : f64} : () -> f64
  %11 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
  %12 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %13 = "arith.constant"() {value = 1 : i32} : () -> i32
  %14 = "llvm.mlir.constant"() {value = 0 : i32} : () -> i32
  %15 = "arith.constant"() {value = 0 : i32} : () -> i32
  %16 = "llvm.call"(%7) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %17 = "llvm.bitcast"(%16) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
  %18 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %19 = "llvm.call"(%9) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %20 = "llvm.bitcast"(%19) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  "llvm.store"(%20, %18) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
  "scf.for"(%3, %1, %5) ({
  ^bb0(%arg2: index):
    %21 = "builtin.unrealized_conversion_cast"(%arg2) : (index) -> i64
    %22 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %23 = "llvm.load"(%22) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %24 = "arith.index_cast"(%arg2) : (index) -> i64
    %25 = "llvm.getelementptr"(%23, %24) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %26 = "llvm.getelementptr"(%25) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(%15, %26) : (i32, !llvm.ptr<i32>) -> ()
    "scf.yield"() : () -> ()
  }) : (index, index, index) -> ()
  "llvm.call"(%17, %14, %12, %10) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
  "func.call"(%17, %15, %13, %11) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
  "llvm.return"(%14) : (i32) -> ()
  "func.return"(%15) : (i32) -> ()
}) {function_type = !llvm.func<i32 (i32, ptr<ptr<i8>>)>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.func'(0x7fd610b08100) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.func -> ()' {
Trying to match "(anonymous namespace)::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x7fd60ff0f0b0)
    ** Erase   : 'func.func'(0x7fd610b08100)
"(anonymous namespace)::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x7fd60ff0f0b0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: builtin.module
'llvm.return' op must be the last operation in the parent block
'func.func' op symbol declaration cannot have public visibility
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"builtin.module"() ({
  "llvm.func"() ({
  }) {function_type = !llvm.func<i32 (ptr<i8>, ...)>, linkage = #llvm.linkage<external>, sym_name = "printf"} : () -> ()
  "llvm.mlir.global"() ({
  }) {addr_space = 0 : i32, constant, global_type = !llvm.array<33 x i8>, linkage = #llvm.linkage<internal>, sym_name = "str0", unnamed_addr = 0 : i64, value = "Too many neighbours for node %d\0A\00"} : () -> ()
  "llvm.func"() ({
  }) {function_type = !llvm.func<ptr<i8> (i64)>, linkage = #llvm.linkage<external>, sym_name = "malloc"} : () -> ()
  "llvm.func"() ({
  ^bb0(%arg0: i32, %arg1: !llvm.ptr<ptr<i8>>):
    %0 = "llvm.mlir.constant"() {value = 2000000 : index} : () -> i64
    %1 = "arith.constant"() {value = 2000000 : index} : () -> index
    %2 = "llvm.mlir.constant"() {value = 0 : index} : () -> i64
    %3 = "arith.constant"() {value = 0 : index} : () -> index
    %4 = "llvm.mlir.constant"() {value = 1 : index} : () -> i64
    %5 = "arith.constant"() {value = 1 : index} : () -> index
    %6 = "llvm.mlir.constant"() {value = 16 : i64} : () -> i64
    %7 = "arith.constant"() {value = 16 : i64} : () -> i64
    %8 = "llvm.mlir.constant"() {value = 272000000 : i64} : () -> i64
    %9 = "arith.constant"() {value = 272000000 : i64} : () -> i64
    %10 = "llvm.mlir.constant"() {value = 5.000000e-01 : f64} : () -> f64
    %11 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
    %12 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
    %13 = "arith.constant"() {value = 1 : i32} : () -> i32
    %14 = "llvm.mlir.constant"() {value = 0 : i32} : () -> i32
    %15 = "arith.constant"() {value = 0 : i32} : () -> i32
    %16 = "llvm.call"(%7) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %17 = "llvm.bitcast"(%16) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
    %18 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %19 = "llvm.call"(%9) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %20 = "llvm.bitcast"(%19) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    "llvm.store"(%20, %18) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
    "scf.for"(%3, %1, %5) ({
    ^bb0(%arg2: index):
      %21 = "builtin.unrealized_conversion_cast"(%arg2) : (index) -> i64
      %22 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
      %23 = "llvm.load"(%22) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
      %24 = "arith.index_cast"(%arg2) : (index) -> i64
      %25 = "llvm.getelementptr"(%23, %24) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
      %26 = "llvm.getelementptr"(%25) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
      "llvm.store"(%15, %26) : (i32, !llvm.ptr<i32>) -> ()
      "scf.yield"() : () -> ()
    }) : (index, index, index) -> ()
    "llvm.call"(%17, %14, %12, %10) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
    "func.call"(%17, %15, %13, %11) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
    "llvm.return"(%14) : (i32) -> ()
    "func.return"(%15) : (i32) -> ()
  }) {function_type = !llvm.func<i32 (i32, ptr<ptr<i8>>)>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()
  "func.func"() ({
  }) {function_type = (i32, !llvm.ptr<ptr<i8>>) -> i32, llvm.linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()
  "llvm.func"() ({
  ^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
    %0 = "arith.constant"() {value = 1 : i32} : () -> i32
    %1 = "arith.constant"() {value = 16 : i32} : () -> i32
    %2 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %3 = "llvm.load"(%2) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %4 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
    %5 = "arith.index_cast"(%4) : (index) -> i64
    %6 = "llvm.getelementptr"(%3, %5) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %7 = "llvm.getelementptr"(%6) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %8 = "llvm.load"(%7) : (!llvm.ptr<i32>) -> i32
    %9 = "arith.cmpi"(%8, %1) {predicate = 5 : i64} : (i32, i32) -> i1
    "scf.if"(%9) ({
      %24 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
      %25 = "llvm.getelementptr"(%24) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
      %26 = "llvm.call"(%25, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
      "func.call"(%0) {callee = @exit} : (i32) -> ()
      "scf.yield"() : () -> ()
    }, {
    }) : (i1) -> ()
    %10 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %11 = "llvm.load"(%10) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %12 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
    %13 = "arith.index_cast"(%12) : (index) -> i64
    %14 = "llvm.getelementptr"(%11, %13) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %15 = "llvm.getelementptr"(%14) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
    %16 = "llvm.getelementptr"(%15) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %17 = "llvm.getelementptr"(%14) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %18 = "llvm.load"(%17) : (!llvm.ptr<i32>) -> i32
    %19 = "arith.addi"(%18, %0) : (i32, i32) -> i32
    "llvm.store"(%19, %17) : (i32, !llvm.ptr<i32>) -> ()
    %20 = "arith.index_cast"(%18) : (i32) -> index
    %21 = "arith.index_cast"(%20) : (index) -> i64
    %22 = "llvm.getelementptr"(%16, %21) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %23 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
    "llvm.store"(%23, %22) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
    "func.return"() : () -> ()
  }) {function_type = !llvm.func<void (ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()
  "func.func"() ({
  }) {function_type = (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> (), llvm.linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()
  "func.func"() ({
  }) {function_type = (i32) -> (), llvm.linkage = #llvm.linkage<external>, sym_name = "exit", sym_visibility = "private"} : () -> ()
  "func.func"() ({
  ^bb0(%arg0: i32, %arg1: f64):
    %0 = "arith.constant"() {value = 16 : i64} : () -> i64
    %1 = "llvm.call"(%0) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %2 = "llvm.bitcast"(%1) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(f64, i32)>>
    %3 = "llvm.getelementptr"(%2) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(%arg0, %3) : (i32, !llvm.ptr<i32>) -> ()
    %4 = "llvm.getelementptr"(%2) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<f64>
    "llvm.store"(%arg1, %4) : (f64, !llvm.ptr<f64>) -> ()
    "func.return"(%2) : (!llvm.ptr<struct<(f64, i32)>>) -> ()
  }) {function_type = (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>, llvm.linkage = #llvm.linkage<external>, sym_name = "new_graph_node"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fd61081e930) {
  %0 = "arith.constant"() {value = 1 : i32} : () -> i32

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.constant'(0x7fd610c05530)
    ** Replace : 'arith.constant'(0x7fd61081e930)
"(anonymous namespace)::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x7fd610c05530) {
      %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
  %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32
  %2 = "arith.constant"() {value = 16 : i32} : () -> i32
  %3 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %4 = "llvm.load"(%3) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %5 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %6 = "arith.index_cast"(%5) : (index) -> i64
  %7 = "llvm.getelementptr"(%4, %6) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %8 = "llvm.getelementptr"(%7) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %9 = "llvm.load"(%8) : (!llvm.ptr<i32>) -> i32
  %10 = "arith.cmpi"(%9, %2) {predicate = 5 : i64} : (i32, i32) -> i1
  "scf.if"(%10) ({
    %25 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
    %26 = "llvm.getelementptr"(%25) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
    %27 = "llvm.call"(%26, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
    "func.call"(%1) {callee = @exit} : (i32) -> ()
    "scf.yield"() : () -> ()
  }, {
  }) : (i1) -> ()
  %11 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %12 = "llvm.load"(%11) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %13 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %14 = "arith.index_cast"(%13) : (index) -> i64
  %15 = "llvm.getelementptr"(%12, %14) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %16 = "llvm.getelementptr"(%15) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
  %17 = "llvm.getelementptr"(%16) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %18 = "llvm.getelementptr"(%15) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %19 = "llvm.load"(%18) : (!llvm.ptr<i32>) -> i32
  %20 = "arith.addi"(%19, %1) : (i32, i32) -> i32
  "llvm.store"(%20, %18) : (i32, !llvm.ptr<i32>) -> ()
  %21 = "arith.index_cast"(%19) : (i32) -> index
  %22 = "arith.index_cast"(%21) : (index) -> i64
  %23 = "llvm.getelementptr"(%17, %22) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %24 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
  "llvm.store"(%24, %23) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
  "func.return"() : () -> ()
}) {function_type = !llvm.func<void (ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fd61081ed50) {
  %2 = "arith.constant"() {value = 16 : i32} : () -> i32

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.constant'(0x7fd610a218c0)
    ** Replace : 'arith.constant'(0x7fd61081ed50)
"(anonymous namespace)::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x7fd610a218c0) {
      %2 = "llvm.mlir.constant"() {value = 16 : i32} : () -> i32

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
  %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32
  %2 = "llvm.mlir.constant"() {value = 16 : i32} : () -> i32
  %3 = "arith.constant"() {value = 16 : i32} : () -> i32
  %4 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %5 = "llvm.load"(%4) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %6 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %7 = "arith.index_cast"(%6) : (index) -> i64
  %8 = "llvm.getelementptr"(%5, %7) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %9 = "llvm.getelementptr"(%8) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %10 = "llvm.load"(%9) : (!llvm.ptr<i32>) -> i32
  %11 = "arith.cmpi"(%10, %3) {predicate = 5 : i64} : (i32, i32) -> i1
  "scf.if"(%11) ({
    %26 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
    %27 = "llvm.getelementptr"(%26) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
    %28 = "llvm.call"(%27, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
    "func.call"(%1) {callee = @exit} : (i32) -> ()
    "scf.yield"() : () -> ()
  }, {
  }) : (i1) -> ()
  %12 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %13 = "llvm.load"(%12) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %14 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %15 = "arith.index_cast"(%14) : (index) -> i64
  %16 = "llvm.getelementptr"(%13, %15) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %17 = "llvm.getelementptr"(%16) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
  %18 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %19 = "llvm.getelementptr"(%16) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %20 = "llvm.load"(%19) : (!llvm.ptr<i32>) -> i32
  %21 = "arith.addi"(%20, %1) : (i32, i32) -> i32
  "llvm.store"(%21, %19) : (i32, !llvm.ptr<i32>) -> ()
  %22 = "arith.index_cast"(%20) : (i32) -> index
  %23 = "arith.index_cast"(%22) : (index) -> i64
  %24 = "llvm.getelementptr"(%18, %23) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %25 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
  "llvm.store"(%25, %24) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
  "func.return"() : () -> ()
}) {function_type = !llvm.func<void (ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fd61081ede0) {
  %4 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x7fd61081ef30) {
  %5 = "llvm.load"(%4) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.index_cast'(0x7fd61081efb0) {
  %6 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOpLowering"
    ** Insert  : 'llvm.sext'(0x7fd610820730)
    ** Replace : 'arith.index_cast'(0x7fd61081efb0)
"(anonymous namespace)::IndexCastOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.sext'(0x7fd610820730) {
      %6 = "llvm.sext"(%arg1) : (i32) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
  %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32
  %2 = "llvm.mlir.constant"() {value = 16 : i32} : () -> i32
  %3 = "arith.constant"() {value = 16 : i32} : () -> i32
  %4 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %5 = "llvm.load"(%4) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %6 = "llvm.sext"(%arg1) : (i32) -> i64
  %7 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %8 = "arith.index_cast"(%7) : (index) -> i64
  %9 = "llvm.getelementptr"(%5, %8) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %10 = "llvm.getelementptr"(%9) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %11 = "llvm.load"(%10) : (!llvm.ptr<i32>) -> i32
  %12 = "arith.cmpi"(%11, %3) {predicate = 5 : i64} : (i32, i32) -> i1
  "scf.if"(%12) ({
    %27 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
    %28 = "llvm.getelementptr"(%27) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
    %29 = "llvm.call"(%28, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
    "func.call"(%1) {callee = @exit} : (i32) -> ()
    "scf.yield"() : () -> ()
  }, {
  }) : (i1) -> ()
  %13 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %14 = "llvm.load"(%13) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %15 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %16 = "arith.index_cast"(%15) : (index) -> i64
  %17 = "llvm.getelementptr"(%14, %16) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %18 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
  %19 = "llvm.getelementptr"(%18) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %20 = "llvm.getelementptr"(%17) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %21 = "llvm.load"(%20) : (!llvm.ptr<i32>) -> i32
  %22 = "arith.addi"(%21, %1) : (i32, i32) -> i32
  "llvm.store"(%22, %20) : (i32, !llvm.ptr<i32>) -> ()
  %23 = "arith.index_cast"(%21) : (i32) -> index
  %24 = "arith.index_cast"(%23) : (index) -> i64
  %25 = "llvm.getelementptr"(%19, %24) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %26 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
  "llvm.store"(%26, %25) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
  "func.return"() : () -> ()
}) {function_type = !llvm.func<void (ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.index_cast'(0x7fd61081f030) {
  %8 = "arith.index_cast"(%7) : (index) -> i64

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOpLowering"
    ** Replace : 'arith.index_cast'(0x7fd61081f030)
"(anonymous namespace)::IndexCastOpLowering" result 1
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
  %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32
  %2 = "llvm.mlir.constant"() {value = 16 : i32} : () -> i32
  %3 = "arith.constant"() {value = 16 : i32} : () -> i32
  %4 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %5 = "llvm.load"(%4) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %6 = "llvm.sext"(%arg1) : (i32) -> i64
  %7 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %8 = "arith.index_cast"(%7) : (index) -> i64
  %9 = "llvm.getelementptr"(%5, %8) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %10 = "llvm.getelementptr"(%9) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %11 = "llvm.load"(%10) : (!llvm.ptr<i32>) -> i32
  %12 = "arith.cmpi"(%11, %3) {predicate = 5 : i64} : (i32, i32) -> i1
  "scf.if"(%12) ({
    %27 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
    %28 = "llvm.getelementptr"(%27) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
    %29 = "llvm.call"(%28, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
    "func.call"(%1) {callee = @exit} : (i32) -> ()
    "scf.yield"() : () -> ()
  }, {
  }) : (i1) -> ()
  %13 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %14 = "llvm.load"(%13) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %15 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %16 = "arith.index_cast"(%15) : (index) -> i64
  %17 = "llvm.getelementptr"(%14, %16) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %18 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
  %19 = "llvm.getelementptr"(%18) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %20 = "llvm.getelementptr"(%17) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %21 = "llvm.load"(%20) : (!llvm.ptr<i32>) -> i32
  %22 = "arith.addi"(%21, %1) : (i32, i32) -> i32
  "llvm.store"(%22, %20) : (i32, !llvm.ptr<i32>) -> ()
  %23 = "arith.index_cast"(%21) : (i32) -> index
  %24 = "arith.index_cast"(%23) : (index) -> i64
  %25 = "llvm.getelementptr"(%19, %24) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %26 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
  "llvm.store"(%26, %25) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
  "func.return"() : () -> ()
}) {function_type = !llvm.func<void (ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fd61081f170) {
  %9 = "llvm.getelementptr"(%5, %8) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fd61081f260) {
  %10 = "llvm.getelementptr"(%9) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x7fd61081f2e0) {
  %11 = "llvm.load"(%10) : (!llvm.ptr<i32>) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.cmpi'(0x7fd61081f4f0) {
  %12 = "arith.cmpi"(%11, %3) {predicate = 5 : i64} : (i32, i32) -> i1

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.cmpi -> ()' {
Trying to match "(anonymous namespace)::CmpIOpLowering"
    ** Insert  : 'llvm.icmp'(0x7fd610b09590)
    ** Replace : 'arith.cmpi'(0x7fd61081f4f0)
"(anonymous namespace)::CmpIOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.icmp'(0x7fd610b09590) {
      %12 = "llvm.icmp"(%11, %2) {predicate = 5 : i64} : (i32, i32) -> i1

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
  %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32
  %2 = "llvm.mlir.constant"() {value = 16 : i32} : () -> i32
  %3 = "arith.constant"() {value = 16 : i32} : () -> i32
  %4 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %5 = "llvm.load"(%4) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %6 = "llvm.sext"(%arg1) : (i32) -> i64
  %7 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %8 = "arith.index_cast"(%7) : (index) -> i64
  %9 = "llvm.getelementptr"(%5, %8) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %10 = "llvm.getelementptr"(%9) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %11 = "llvm.load"(%10) : (!llvm.ptr<i32>) -> i32
  %12 = "llvm.icmp"(%11, %2) {predicate = 5 : i64} : (i32, i32) -> i1
  %13 = "arith.cmpi"(%11, %3) {predicate = 5 : i64} : (i32, i32) -> i1
  "scf.if"(%13) ({
    %28 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
    %29 = "llvm.getelementptr"(%28) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
    %30 = "llvm.call"(%29, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
    "func.call"(%1) {callee = @exit} : (i32) -> ()
    "scf.yield"() : () -> ()
  }, {
  }) : (i1) -> ()
  %14 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %15 = "llvm.load"(%14) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %16 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %17 = "arith.index_cast"(%16) : (index) -> i64
  %18 = "llvm.getelementptr"(%15, %17) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %19 = "llvm.getelementptr"(%18) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
  %20 = "llvm.getelementptr"(%19) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %21 = "llvm.getelementptr"(%18) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %22 = "llvm.load"(%21) : (!llvm.ptr<i32>) -> i32
  %23 = "arith.addi"(%22, %1) : (i32, i32) -> i32
  "llvm.store"(%23, %21) : (i32, !llvm.ptr<i32>) -> ()
  %24 = "arith.index_cast"(%22) : (i32) -> index
  %25 = "arith.index_cast"(%24) : (index) -> i64
  %26 = "llvm.getelementptr"(%20, %25) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %27 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
  "llvm.store"(%27, %26) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
  "func.return"() : () -> ()
}) {function_type = !llvm.func<void (ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'scf.if'(0x7fd610b07620) {
  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.addressof'(0x7fd610b04120) {
  %28 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fd610b06e90) {
  %29 = "llvm.getelementptr"(%28) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x7fd610b072c0) {
  %30 = "llvm.call"(%29, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.call'(0x7fd610b075b0) {
  "func.call"(%1) {callee = @exit} : (i32) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.call -> ()' {
Trying to match "(anonymous namespace)::CallOpLowering"
    ** Insert  : 'llvm.call'(0x7fd610b08520)
    ** Replace : 'func.call'(0x7fd610b075b0)
"(anonymous namespace)::CallOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.call'(0x7fd610b08520) {
      "llvm.call"(%0) {callee = @exit} : (i32) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'llvm.call' op 'exit' does not reference a valid LLVM function
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
  %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32
  %2 = "llvm.mlir.constant"() {value = 16 : i32} : () -> i32
  %3 = "arith.constant"() {value = 16 : i32} : () -> i32
  %4 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %5 = "llvm.load"(%4) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %6 = "llvm.sext"(%arg1) : (i32) -> i64
  %7 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %8 = "arith.index_cast"(%7) : (index) -> i64
  %9 = "llvm.getelementptr"(%5, %8) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %10 = "llvm.getelementptr"(%9) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %11 = "llvm.load"(%10) : (!llvm.ptr<i32>) -> i32
  %12 = "llvm.icmp"(%11, %2) {predicate = 5 : i64} : (i32, i32) -> i1
  %13 = "arith.cmpi"(%11, %3) {predicate = 5 : i64} : (i32, i32) -> i1
  "scf.if"(%13) ({
    %28 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
    %29 = "llvm.getelementptr"(%28) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
    %30 = "llvm.call"(%29, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
    "llvm.call"(%0) {callee = @exit} : (i32) -> ()
    "func.call"(%1) {callee = @exit} : (i32) -> ()
    "scf.yield"() : () -> ()
  }, {
  }) : (i1) -> ()
  %14 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %15 = "llvm.load"(%14) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %16 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %17 = "arith.index_cast"(%16) : (index) -> i64
  %18 = "llvm.getelementptr"(%15, %17) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %19 = "llvm.getelementptr"(%18) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
  %20 = "llvm.getelementptr"(%19) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %21 = "llvm.getelementptr"(%18) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %22 = "llvm.load"(%21) : (!llvm.ptr<i32>) -> i32
  %23 = "arith.addi"(%22, %1) : (i32, i32) -> i32
  "llvm.store"(%23, %21) : (i32, !llvm.ptr<i32>) -> ()
  %24 = "arith.index_cast"(%22) : (i32) -> index
  %25 = "arith.index_cast"(%24) : (index) -> i64
  %26 = "llvm.getelementptr"(%20, %25) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %27 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
  "llvm.store"(%27, %26) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
  "func.return"() : () -> ()
}) {function_type = !llvm.func<void (ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'scf.yield'(0x7fd610b06bb0) {
  "scf.yield"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fd610b076d0) {
  %14 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x7fd610b06c50) {
  %15 = "llvm.load"(%14) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.index_cast'(0x7fd610b07750) {
  %16 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOpLowering"
    ** Insert  : 'llvm.sext'(0x7fd610c05580)
    ** Replace : 'arith.index_cast'(0x7fd610b07750)
"(anonymous namespace)::IndexCastOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.sext'(0x7fd610c05580) {
      %16 = "llvm.sext"(%arg1) : (i32) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'llvm.call' op 'exit' does not reference a valid LLVM function
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
  %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32
  %2 = "llvm.mlir.constant"() {value = 16 : i32} : () -> i32
  %3 = "arith.constant"() {value = 16 : i32} : () -> i32
  %4 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %5 = "llvm.load"(%4) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %6 = "llvm.sext"(%arg1) : (i32) -> i64
  %7 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %8 = "arith.index_cast"(%7) : (index) -> i64
  %9 = "llvm.getelementptr"(%5, %8) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %10 = "llvm.getelementptr"(%9) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %11 = "llvm.load"(%10) : (!llvm.ptr<i32>) -> i32
  %12 = "llvm.icmp"(%11, %2) {predicate = 5 : i64} : (i32, i32) -> i1
  %13 = "arith.cmpi"(%11, %3) {predicate = 5 : i64} : (i32, i32) -> i1
  "scf.if"(%13) ({
    %29 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
    %30 = "llvm.getelementptr"(%29) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
    %31 = "llvm.call"(%30, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
    "llvm.call"(%0) {callee = @exit} : (i32) -> ()
    "func.call"(%1) {callee = @exit} : (i32) -> ()
    "scf.yield"() : () -> ()
  }, {
  }) : (i1) -> ()
  %14 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %15 = "llvm.load"(%14) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %16 = "llvm.sext"(%arg1) : (i32) -> i64
  %17 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %18 = "arith.index_cast"(%17) : (index) -> i64
  %19 = "llvm.getelementptr"(%15, %18) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %20 = "llvm.getelementptr"(%19) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
  %21 = "llvm.getelementptr"(%20) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %22 = "llvm.getelementptr"(%19) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %23 = "llvm.load"(%22) : (!llvm.ptr<i32>) -> i32
  %24 = "arith.addi"(%23, %1) : (i32, i32) -> i32
  "llvm.store"(%24, %22) : (i32, !llvm.ptr<i32>) -> ()
  %25 = "arith.index_cast"(%23) : (i32) -> index
  %26 = "arith.index_cast"(%25) : (index) -> i64
  %27 = "llvm.getelementptr"(%21, %26) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %28 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
  "llvm.store"(%28, %27) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
  "func.return"() : () -> ()
}) {function_type = !llvm.func<void (ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.index_cast'(0x7fd610b077d0) {
  %18 = "arith.index_cast"(%17) : (index) -> i64

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOpLowering"
    ** Replace : 'arith.index_cast'(0x7fd610b077d0)
"(anonymous namespace)::IndexCastOpLowering" result 1
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'llvm.call' op 'exit' does not reference a valid LLVM function
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
  %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32
  %2 = "llvm.mlir.constant"() {value = 16 : i32} : () -> i32
  %3 = "arith.constant"() {value = 16 : i32} : () -> i32
  %4 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %5 = "llvm.load"(%4) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %6 = "llvm.sext"(%arg1) : (i32) -> i64
  %7 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %8 = "arith.index_cast"(%7) : (index) -> i64
  %9 = "llvm.getelementptr"(%5, %8) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %10 = "llvm.getelementptr"(%9) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %11 = "llvm.load"(%10) : (!llvm.ptr<i32>) -> i32
  %12 = "llvm.icmp"(%11, %2) {predicate = 5 : i64} : (i32, i32) -> i1
  %13 = "arith.cmpi"(%11, %3) {predicate = 5 : i64} : (i32, i32) -> i1
  "scf.if"(%13) ({
    %29 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
    %30 = "llvm.getelementptr"(%29) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
    %31 = "llvm.call"(%30, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
    "llvm.call"(%0) {callee = @exit} : (i32) -> ()
    "func.call"(%1) {callee = @exit} : (i32) -> ()
    "scf.yield"() : () -> ()
  }, {
  }) : (i1) -> ()
  %14 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %15 = "llvm.load"(%14) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %16 = "llvm.sext"(%arg1) : (i32) -> i64
  %17 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %18 = "arith.index_cast"(%17) : (index) -> i64
  %19 = "llvm.getelementptr"(%15, %18) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %20 = "llvm.getelementptr"(%19) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
  %21 = "llvm.getelementptr"(%20) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %22 = "llvm.getelementptr"(%19) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %23 = "llvm.load"(%22) : (!llvm.ptr<i32>) -> i32
  %24 = "arith.addi"(%23, %1) : (i32, i32) -> i32
  "llvm.store"(%24, %22) : (i32, !llvm.ptr<i32>) -> ()
  %25 = "arith.index_cast"(%23) : (i32) -> index
  %26 = "arith.index_cast"(%25) : (index) -> i64
  %27 = "llvm.getelementptr"(%21, %26) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %28 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
  "llvm.store"(%28, %27) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
  "func.return"() : () -> ()
}) {function_type = !llvm.func<void (ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fd610b07910) {
  %19 = "llvm.getelementptr"(%15, %18) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fd610b07c90) {
  %20 = "llvm.getelementptr"(%19) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fd610b07d10) {
  %21 = "llvm.getelementptr"(%20) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fd610b07de0) {
  %22 = "llvm.getelementptr"(%19) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x7fd610b07e60) {
  %23 = "llvm.load"(%22) : (!llvm.ptr<i32>) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.addi'(0x7fd610b08070) {
  %24 = "arith.addi"(%23, %1) : (i32, i32) -> i32

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.addi -> ()' {
Trying to match "mlir::VectorConvertToLLVMPattern<mlir::arith::AddIOp, mlir::LLVM::AddOp>"
    ** Insert  : 'llvm.add'(0x7fd610c05630)
    ** Replace : 'arith.addi'(0x7fd610b08070)
"mlir::VectorConvertToLLVMPattern<mlir::arith::AddIOp, mlir::LLVM::AddOp>" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.add'(0x7fd610c05630) {
      %24 = "llvm.add"(%23, %0) : (i32, i32) -> i32

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'llvm.call' op 'exit' does not reference a valid LLVM function
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
  %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32
  %2 = "llvm.mlir.constant"() {value = 16 : i32} : () -> i32
  %3 = "arith.constant"() {value = 16 : i32} : () -> i32
  %4 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %5 = "llvm.load"(%4) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %6 = "llvm.sext"(%arg1) : (i32) -> i64
  %7 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %8 = "arith.index_cast"(%7) : (index) -> i64
  %9 = "llvm.getelementptr"(%5, %8) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %10 = "llvm.getelementptr"(%9) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %11 = "llvm.load"(%10) : (!llvm.ptr<i32>) -> i32
  %12 = "llvm.icmp"(%11, %2) {predicate = 5 : i64} : (i32, i32) -> i1
  %13 = "arith.cmpi"(%11, %3) {predicate = 5 : i64} : (i32, i32) -> i1
  "scf.if"(%13) ({
    %30 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
    %31 = "llvm.getelementptr"(%30) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
    %32 = "llvm.call"(%31, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
    "llvm.call"(%0) {callee = @exit} : (i32) -> ()
    "func.call"(%1) {callee = @exit} : (i32) -> ()
    "scf.yield"() : () -> ()
  }, {
  }) : (i1) -> ()
  %14 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %15 = "llvm.load"(%14) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %16 = "llvm.sext"(%arg1) : (i32) -> i64
  %17 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %18 = "arith.index_cast"(%17) : (index) -> i64
  %19 = "llvm.getelementptr"(%15, %18) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %20 = "llvm.getelementptr"(%19) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
  %21 = "llvm.getelementptr"(%20) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %22 = "llvm.getelementptr"(%19) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %23 = "llvm.load"(%22) : (!llvm.ptr<i32>) -> i32
  %24 = "llvm.add"(%23, %0) : (i32, i32) -> i32
  %25 = "arith.addi"(%23, %1) : (i32, i32) -> i32
  "llvm.store"(%25, %22) : (i32, !llvm.ptr<i32>) -> ()
  %26 = "arith.index_cast"(%23) : (i32) -> index
  %27 = "arith.index_cast"(%26) : (index) -> i64
  %28 = "llvm.getelementptr"(%21, %27) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %29 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
  "llvm.store"(%29, %28) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
  "func.return"() : () -> ()
}) {function_type = !llvm.func<void (ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x7fd610b08180) {
  "llvm.store"(%25, %22) : (i32, !llvm.ptr<i32>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.index_cast'(0x7fd610b08220) {
  %26 = "arith.index_cast"(%23) : (i32) -> index

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOpLowering"
    ** Insert  : 'llvm.sext'(0x7fd6109133c0)
    ** Replace : 'arith.index_cast'(0x7fd610b08220)
"(anonymous namespace)::IndexCastOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.sext'(0x7fd6109133c0) {
      %26 = "llvm.sext"(%23) : (i32) -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'llvm.call' op 'exit' does not reference a valid LLVM function
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
  %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32
  %2 = "llvm.mlir.constant"() {value = 16 : i32} : () -> i32
  %3 = "arith.constant"() {value = 16 : i32} : () -> i32
  %4 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %5 = "llvm.load"(%4) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %6 = "llvm.sext"(%arg1) : (i32) -> i64
  %7 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %8 = "arith.index_cast"(%7) : (index) -> i64
  %9 = "llvm.getelementptr"(%5, %8) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %10 = "llvm.getelementptr"(%9) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %11 = "llvm.load"(%10) : (!llvm.ptr<i32>) -> i32
  %12 = "llvm.icmp"(%11, %2) {predicate = 5 : i64} : (i32, i32) -> i1
  %13 = "arith.cmpi"(%11, %3) {predicate = 5 : i64} : (i32, i32) -> i1
  "scf.if"(%13) ({
    %31 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
    %32 = "llvm.getelementptr"(%31) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
    %33 = "llvm.call"(%32, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
    "llvm.call"(%0) {callee = @exit} : (i32) -> ()
    "func.call"(%1) {callee = @exit} : (i32) -> ()
    "scf.yield"() : () -> ()
  }, {
  }) : (i1) -> ()
  %14 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %15 = "llvm.load"(%14) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %16 = "llvm.sext"(%arg1) : (i32) -> i64
  %17 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %18 = "arith.index_cast"(%17) : (index) -> i64
  %19 = "llvm.getelementptr"(%15, %18) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %20 = "llvm.getelementptr"(%19) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
  %21 = "llvm.getelementptr"(%20) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %22 = "llvm.getelementptr"(%19) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %23 = "llvm.load"(%22) : (!llvm.ptr<i32>) -> i32
  %24 = "llvm.add"(%23, %0) : (i32, i32) -> i32
  %25 = "arith.addi"(%23, %1) : (i32, i32) -> i32
  "llvm.store"(%25, %22) : (i32, !llvm.ptr<i32>) -> ()
  %26 = "llvm.sext"(%23) : (i32) -> i64
  %27 = "arith.index_cast"(%23) : (i32) -> index
  %28 = "arith.index_cast"(%27) : (index) -> i64
  %29 = "llvm.getelementptr"(%21, %28) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %30 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
  "llvm.store"(%30, %29) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
  "func.return"() : () -> ()
}) {function_type = !llvm.func<void (ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.index_cast'(0x7fd610b07ee0) {
  %28 = "arith.index_cast"(%27) : (index) -> i64

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.index_cast -> ()' {
Trying to match "(anonymous namespace)::IndexCastOpLowering"
    ** Replace : 'arith.index_cast'(0x7fd610b07ee0)
"(anonymous namespace)::IndexCastOpLowering" result 1
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'llvm.call' op 'exit' does not reference a valid LLVM function
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
  %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32
  %2 = "llvm.mlir.constant"() {value = 16 : i32} : () -> i32
  %3 = "arith.constant"() {value = 16 : i32} : () -> i32
  %4 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %5 = "llvm.load"(%4) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %6 = "llvm.sext"(%arg1) : (i32) -> i64
  %7 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %8 = "arith.index_cast"(%7) : (index) -> i64
  %9 = "llvm.getelementptr"(%5, %8) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %10 = "llvm.getelementptr"(%9) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %11 = "llvm.load"(%10) : (!llvm.ptr<i32>) -> i32
  %12 = "llvm.icmp"(%11, %2) {predicate = 5 : i64} : (i32, i32) -> i1
  %13 = "arith.cmpi"(%11, %3) {predicate = 5 : i64} : (i32, i32) -> i1
  "scf.if"(%13) ({
    %31 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
    %32 = "llvm.getelementptr"(%31) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
    %33 = "llvm.call"(%32, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
    "llvm.call"(%0) {callee = @exit} : (i32) -> ()
    "func.call"(%1) {callee = @exit} : (i32) -> ()
    "scf.yield"() : () -> ()
  }, {
  }) : (i1) -> ()
  %14 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %15 = "llvm.load"(%14) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %16 = "llvm.sext"(%arg1) : (i32) -> i64
  %17 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %18 = "arith.index_cast"(%17) : (index) -> i64
  %19 = "llvm.getelementptr"(%15, %18) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %20 = "llvm.getelementptr"(%19) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
  %21 = "llvm.getelementptr"(%20) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %22 = "llvm.getelementptr"(%19) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %23 = "llvm.load"(%22) : (!llvm.ptr<i32>) -> i32
  %24 = "llvm.add"(%23, %0) : (i32, i32) -> i32
  %25 = "arith.addi"(%23, %1) : (i32, i32) -> i32
  "llvm.store"(%25, %22) : (i32, !llvm.ptr<i32>) -> ()
  %26 = "llvm.sext"(%23) : (i32) -> i64
  %27 = "arith.index_cast"(%23) : (i32) -> index
  %28 = "arith.index_cast"(%27) : (index) -> i64
  %29 = "llvm.getelementptr"(%21, %28) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %30 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
  "llvm.store"(%30, %29) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
  "func.return"() : () -> ()
}) {function_type = !llvm.func<void (ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fd610b07fb0) {
  %29 = "llvm.getelementptr"(%21, %28) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.call'(0x7fd610b08cb0) {
  %30 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.call -> ()' {
Trying to match "(anonymous namespace)::CallOpLowering"
    ** Insert  : 'llvm.call'(0x7fd610c05d00)
    ** Replace : 'func.call'(0x7fd610b08cb0)
"(anonymous namespace)::CallOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.call'(0x7fd610c05d00) {
      %30 = "llvm.call"(%arg2, %arg3) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'llvm.call' op 'exit' does not reference a valid LLVM function
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
  %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32
  %2 = "llvm.mlir.constant"() {value = 16 : i32} : () -> i32
  %3 = "arith.constant"() {value = 16 : i32} : () -> i32
  %4 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %5 = "llvm.load"(%4) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %6 = "llvm.sext"(%arg1) : (i32) -> i64
  %7 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %8 = "arith.index_cast"(%7) : (index) -> i64
  %9 = "llvm.getelementptr"(%5, %8) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %10 = "llvm.getelementptr"(%9) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %11 = "llvm.load"(%10) : (!llvm.ptr<i32>) -> i32
  %12 = "llvm.icmp"(%11, %2) {predicate = 5 : i64} : (i32, i32) -> i1
  %13 = "arith.cmpi"(%11, %3) {predicate = 5 : i64} : (i32, i32) -> i1
  "scf.if"(%13) ({
    %32 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
    %33 = "llvm.getelementptr"(%32) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
    %34 = "llvm.call"(%33, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
    "llvm.call"(%0) {callee = @exit} : (i32) -> ()
    "func.call"(%1) {callee = @exit} : (i32) -> ()
    "scf.yield"() : () -> ()
  }, {
  }) : (i1) -> ()
  %14 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %15 = "llvm.load"(%14) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %16 = "llvm.sext"(%arg1) : (i32) -> i64
  %17 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %18 = "arith.index_cast"(%17) : (index) -> i64
  %19 = "llvm.getelementptr"(%15, %18) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %20 = "llvm.getelementptr"(%19) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
  %21 = "llvm.getelementptr"(%20) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %22 = "llvm.getelementptr"(%19) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %23 = "llvm.load"(%22) : (!llvm.ptr<i32>) -> i32
  %24 = "llvm.add"(%23, %0) : (i32, i32) -> i32
  %25 = "arith.addi"(%23, %1) : (i32, i32) -> i32
  "llvm.store"(%25, %22) : (i32, !llvm.ptr<i32>) -> ()
  %26 = "llvm.sext"(%23) : (i32) -> i64
  %27 = "arith.index_cast"(%23) : (i32) -> index
  %28 = "arith.index_cast"(%27) : (index) -> i64
  %29 = "llvm.getelementptr"(%21, %28) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %30 = "llvm.call"(%arg2, %arg3) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
  %31 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
  "llvm.store"(%31, %29) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
  "func.return"() : () -> ()
}) {function_type = !llvm.func<void (ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x7fd610b08d90) {
  "llvm.store"(%31, %29) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.return'(0x7fd610b08d40) {
  "func.return"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.return -> ()' {
Trying to match "(anonymous namespace)::ReturnOpLowering"
    ** Insert  : 'llvm.return'(0x7fd610c056c0)
    ** Replace : 'func.return'(0x7fd610b08d40)
"(anonymous namespace)::ReturnOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.return'(0x7fd610c056c0) {
      "llvm.return"() : () -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'llvm.call' op 'exit' does not reference a valid LLVM function
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
  %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
  %1 = "arith.constant"() {value = 1 : i32} : () -> i32
  %2 = "llvm.mlir.constant"() {value = 16 : i32} : () -> i32
  %3 = "arith.constant"() {value = 16 : i32} : () -> i32
  %4 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %5 = "llvm.load"(%4) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %6 = "llvm.sext"(%arg1) : (i32) -> i64
  %7 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %8 = "arith.index_cast"(%7) : (index) -> i64
  %9 = "llvm.getelementptr"(%5, %8) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %10 = "llvm.getelementptr"(%9) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %11 = "llvm.load"(%10) : (!llvm.ptr<i32>) -> i32
  %12 = "llvm.icmp"(%11, %2) {predicate = 5 : i64} : (i32, i32) -> i1
  %13 = "arith.cmpi"(%11, %3) {predicate = 5 : i64} : (i32, i32) -> i1
  "scf.if"(%13) ({
    %32 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
    %33 = "llvm.getelementptr"(%32) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
    %34 = "llvm.call"(%33, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
    "llvm.call"(%0) {callee = @exit} : (i32) -> ()
    "func.call"(%1) {callee = @exit} : (i32) -> ()
    "scf.yield"() : () -> ()
  }, {
  }) : (i1) -> ()
  %14 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
  %15 = "llvm.load"(%14) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %16 = "llvm.sext"(%arg1) : (i32) -> i64
  %17 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
  %18 = "arith.index_cast"(%17) : (index) -> i64
  %19 = "llvm.getelementptr"(%15, %18) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
  %20 = "llvm.getelementptr"(%19) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
  %21 = "llvm.getelementptr"(%20) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %22 = "llvm.getelementptr"(%19) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
  %23 = "llvm.load"(%22) : (!llvm.ptr<i32>) -> i32
  %24 = "llvm.add"(%23, %0) : (i32, i32) -> i32
  %25 = "arith.addi"(%23, %1) : (i32, i32) -> i32
  "llvm.store"(%25, %22) : (i32, !llvm.ptr<i32>) -> ()
  %26 = "llvm.sext"(%23) : (i32) -> i64
  %27 = "arith.index_cast"(%23) : (i32) -> index
  %28 = "arith.index_cast"(%27) : (index) -> i64
  %29 = "llvm.getelementptr"(%21, %28) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
  %30 = "llvm.call"(%arg2, %arg3) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
  %31 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
  "llvm.store"(%31, %29) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
  "llvm.return"() : () -> ()
  "func.return"() : () -> ()
}) {function_type = !llvm.func<void (ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.func'(0x7fd610b079a0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.func -> ()' {
Trying to match "(anonymous namespace)::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x7fd60ff0f5a0)
    ** Erase   : 'func.func'(0x7fd610b079a0)
"(anonymous namespace)::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x7fd60ff0f5a0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: builtin.module
'llvm.return' op must be the last operation in the parent block
'func.func' op symbol declaration cannot have public visibility
'llvm.call' op 'new_graph_node' does not reference a valid LLVM function
'func.func' op symbol declaration cannot have public visibility
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"builtin.module"() ({
  "llvm.func"() ({
  }) {function_type = !llvm.func<i32 (ptr<i8>, ...)>, linkage = #llvm.linkage<external>, sym_name = "printf"} : () -> ()
  "llvm.mlir.global"() ({
  }) {addr_space = 0 : i32, constant, global_type = !llvm.array<33 x i8>, linkage = #llvm.linkage<internal>, sym_name = "str0", unnamed_addr = 0 : i64, value = "Too many neighbours for node %d\0A\00"} : () -> ()
  "llvm.func"() ({
  }) {function_type = !llvm.func<ptr<i8> (i64)>, linkage = #llvm.linkage<external>, sym_name = "malloc"} : () -> ()
  "llvm.func"() ({
  ^bb0(%arg0: i32, %arg1: !llvm.ptr<ptr<i8>>):
    %0 = "llvm.mlir.constant"() {value = 2000000 : index} : () -> i64
    %1 = "arith.constant"() {value = 2000000 : index} : () -> index
    %2 = "llvm.mlir.constant"() {value = 0 : index} : () -> i64
    %3 = "arith.constant"() {value = 0 : index} : () -> index
    %4 = "llvm.mlir.constant"() {value = 1 : index} : () -> i64
    %5 = "arith.constant"() {value = 1 : index} : () -> index
    %6 = "llvm.mlir.constant"() {value = 16 : i64} : () -> i64
    %7 = "arith.constant"() {value = 16 : i64} : () -> i64
    %8 = "llvm.mlir.constant"() {value = 272000000 : i64} : () -> i64
    %9 = "arith.constant"() {value = 272000000 : i64} : () -> i64
    %10 = "llvm.mlir.constant"() {value = 5.000000e-01 : f64} : () -> f64
    %11 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
    %12 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
    %13 = "arith.constant"() {value = 1 : i32} : () -> i32
    %14 = "llvm.mlir.constant"() {value = 0 : i32} : () -> i32
    %15 = "arith.constant"() {value = 0 : i32} : () -> i32
    %16 = "llvm.call"(%7) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %17 = "llvm.bitcast"(%16) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
    %18 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %19 = "llvm.call"(%9) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %20 = "llvm.bitcast"(%19) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    "llvm.store"(%20, %18) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
    "scf.for"(%3, %1, %5) ({
    ^bb0(%arg2: index):
      %21 = "builtin.unrealized_conversion_cast"(%arg2) : (index) -> i64
      %22 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
      %23 = "llvm.load"(%22) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
      %24 = "arith.index_cast"(%arg2) : (index) -> i64
      %25 = "llvm.getelementptr"(%23, %24) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
      %26 = "llvm.getelementptr"(%25) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
      "llvm.store"(%15, %26) : (i32, !llvm.ptr<i32>) -> ()
      "scf.yield"() : () -> ()
    }) : (index, index, index) -> ()
    "llvm.call"(%17, %14, %12, %10) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
    "func.call"(%17, %15, %13, %11) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
    "llvm.return"(%14) : (i32) -> ()
    "func.return"(%15) : (i32) -> ()
  }) {function_type = !llvm.func<i32 (i32, ptr<ptr<i8>>)>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()
  "func.func"() ({
  }) {function_type = (i32, !llvm.ptr<ptr<i8>>) -> i32, llvm.linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()
  "llvm.func"() ({
  ^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
    %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
    %1 = "arith.constant"() {value = 1 : i32} : () -> i32
    %2 = "llvm.mlir.constant"() {value = 16 : i32} : () -> i32
    %3 = "arith.constant"() {value = 16 : i32} : () -> i32
    %4 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %5 = "llvm.load"(%4) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %6 = "llvm.sext"(%arg1) : (i32) -> i64
    %7 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
    %8 = "arith.index_cast"(%7) : (index) -> i64
    %9 = "llvm.getelementptr"(%5, %8) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %10 = "llvm.getelementptr"(%9) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %11 = "llvm.load"(%10) : (!llvm.ptr<i32>) -> i32
    %12 = "llvm.icmp"(%11, %2) {predicate = 5 : i64} : (i32, i32) -> i1
    %13 = "arith.cmpi"(%11, %3) {predicate = 5 : i64} : (i32, i32) -> i1
    "scf.if"(%13) ({
      %32 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
      %33 = "llvm.getelementptr"(%32) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
      %34 = "llvm.call"(%33, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
      "llvm.call"(%0) {callee = @exit} : (i32) -> ()
      "func.call"(%1) {callee = @exit} : (i32) -> ()
      "scf.yield"() : () -> ()
    }, {
    }) : (i1) -> ()
    %14 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %15 = "llvm.load"(%14) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %16 = "llvm.sext"(%arg1) : (i32) -> i64
    %17 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
    %18 = "arith.index_cast"(%17) : (index) -> i64
    %19 = "llvm.getelementptr"(%15, %18) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %20 = "llvm.getelementptr"(%19) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
    %21 = "llvm.getelementptr"(%20) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %22 = "llvm.getelementptr"(%19) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %23 = "llvm.load"(%22) : (!llvm.ptr<i32>) -> i32
    %24 = "llvm.add"(%23, %0) : (i32, i32) -> i32
    %25 = "arith.addi"(%23, %1) : (i32, i32) -> i32
    "llvm.store"(%25, %22) : (i32, !llvm.ptr<i32>) -> ()
    %26 = "llvm.sext"(%23) : (i32) -> i64
    %27 = "arith.index_cast"(%23) : (i32) -> index
    %28 = "arith.index_cast"(%27) : (index) -> i64
    %29 = "llvm.getelementptr"(%21, %28) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %30 = "llvm.call"(%arg2, %arg3) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
    %31 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
    "llvm.store"(%31, %29) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
    "llvm.return"() : () -> ()
    "func.return"() : () -> ()
  }) {function_type = !llvm.func<void (ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()
  "func.func"() ({
  }) {function_type = (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> (), llvm.linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()
  "llvm.func"() ({
  }) {function_type = !llvm.func<void (i32)>, linkage = #llvm.linkage<external>, sym_name = "exit", sym_visibility = "private"} : () -> ()
  "func.func"() ({
  }) {function_type = (i32) -> (), llvm.linkage = #llvm.linkage<external>, sym_name = "exit", sym_visibility = "private"} : () -> ()
  "func.func"() ({
  ^bb0(%arg0: i32, %arg1: f64):
    %0 = "arith.constant"() {value = 16 : i64} : () -> i64
    %1 = "llvm.call"(%0) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %2 = "llvm.bitcast"(%1) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(f64, i32)>>
    %3 = "llvm.getelementptr"(%2) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(%arg0, %3) : (i32, !llvm.ptr<i32>) -> ()
    %4 = "llvm.getelementptr"(%2) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<f64>
    "llvm.store"(%arg1, %4) : (f64, !llvm.ptr<f64>) -> ()
    "func.return"(%2) : (!llvm.ptr<struct<(f64, i32)>>) -> ()
  }) {function_type = (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>, llvm.linkage = #llvm.linkage<external>, sym_name = "new_graph_node"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.func'(0x7fd610b06cc0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.func -> ()' {
Trying to match "(anonymous namespace)::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x7fd6109146e0)
    ** Erase   : 'func.func'(0x7fd610b06cc0)
"(anonymous namespace)::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x7fd6109146e0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: builtin.module
'llvm.return' op must be the last operation in the parent block
'func.func' op symbol declaration cannot have public visibility
'llvm.return' op must be the last operation in the parent block
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"builtin.module"() ({
  "llvm.func"() ({
  }) {function_type = !llvm.func<i32 (ptr<i8>, ...)>, linkage = #llvm.linkage<external>, sym_name = "printf"} : () -> ()
  "llvm.mlir.global"() ({
  }) {addr_space = 0 : i32, constant, global_type = !llvm.array<33 x i8>, linkage = #llvm.linkage<internal>, sym_name = "str0", unnamed_addr = 0 : i64, value = "Too many neighbours for node %d\0A\00"} : () -> ()
  "llvm.func"() ({
  }) {function_type = !llvm.func<ptr<i8> (i64)>, linkage = #llvm.linkage<external>, sym_name = "malloc"} : () -> ()
  "llvm.func"() ({
  ^bb0(%arg0: i32, %arg1: !llvm.ptr<ptr<i8>>):
    %0 = "llvm.mlir.constant"() {value = 2000000 : index} : () -> i64
    %1 = "arith.constant"() {value = 2000000 : index} : () -> index
    %2 = "llvm.mlir.constant"() {value = 0 : index} : () -> i64
    %3 = "arith.constant"() {value = 0 : index} : () -> index
    %4 = "llvm.mlir.constant"() {value = 1 : index} : () -> i64
    %5 = "arith.constant"() {value = 1 : index} : () -> index
    %6 = "llvm.mlir.constant"() {value = 16 : i64} : () -> i64
    %7 = "arith.constant"() {value = 16 : i64} : () -> i64
    %8 = "llvm.mlir.constant"() {value = 272000000 : i64} : () -> i64
    %9 = "arith.constant"() {value = 272000000 : i64} : () -> i64
    %10 = "llvm.mlir.constant"() {value = 5.000000e-01 : f64} : () -> f64
    %11 = "arith.constant"() {value = 5.000000e-01 : f64} : () -> f64
    %12 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
    %13 = "arith.constant"() {value = 1 : i32} : () -> i32
    %14 = "llvm.mlir.constant"() {value = 0 : i32} : () -> i32
    %15 = "arith.constant"() {value = 0 : i32} : () -> i32
    %16 = "llvm.call"(%7) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %17 = "llvm.bitcast"(%16) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
    %18 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %19 = "llvm.call"(%9) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %20 = "llvm.bitcast"(%19) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    "llvm.store"(%20, %18) : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> ()
    "scf.for"(%3, %1, %5) ({
    ^bb0(%arg2: index):
      %21 = "builtin.unrealized_conversion_cast"(%arg2) : (index) -> i64
      %22 = "llvm.getelementptr"(%17) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
      %23 = "llvm.load"(%22) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
      %24 = "arith.index_cast"(%arg2) : (index) -> i64
      %25 = "llvm.getelementptr"(%23, %24) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
      %26 = "llvm.getelementptr"(%25) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
      "llvm.store"(%15, %26) : (i32, !llvm.ptr<i32>) -> ()
      "scf.yield"() : () -> ()
    }) : (index, index, index) -> ()
    "llvm.call"(%17, %14, %12, %10) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
    "func.call"(%17, %15, %13, %11) {callee = @add_edge} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
    "llvm.return"(%14) : (i32) -> ()
    "func.return"(%15) : (i32) -> ()
  }) {function_type = !llvm.func<i32 (i32, ptr<ptr<i8>>)>, linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()
  "func.func"() ({
  }) {function_type = (i32, !llvm.ptr<ptr<i8>>) -> i32, llvm.linkage = #llvm.linkage<external>, sym_name = "main"} : () -> ()
  "llvm.func"() ({
  ^bb0(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64):
    %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32
    %1 = "arith.constant"() {value = 1 : i32} : () -> i32
    %2 = "llvm.mlir.constant"() {value = 16 : i32} : () -> i32
    %3 = "arith.constant"() {value = 16 : i32} : () -> i32
    %4 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %5 = "llvm.load"(%4) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %6 = "llvm.sext"(%arg1) : (i32) -> i64
    %7 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
    %8 = "arith.index_cast"(%7) : (index) -> i64
    %9 = "llvm.getelementptr"(%5, %8) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %10 = "llvm.getelementptr"(%9) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %11 = "llvm.load"(%10) : (!llvm.ptr<i32>) -> i32
    %12 = "llvm.icmp"(%11, %2) {predicate = 5 : i64} : (i32, i32) -> i1
    %13 = "arith.cmpi"(%11, %3) {predicate = 5 : i64} : (i32, i32) -> i1
    "scf.if"(%13) ({
      %32 = "llvm.mlir.addressof"() {global_name = @str0} : () -> !llvm.ptr<array<33 x i8>>
      %33 = "llvm.getelementptr"(%32) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
      %34 = "llvm.call"(%33, <<UNKNOWN SSA VALUE>>) {callee = @printf} : (!llvm.ptr<i8>, i32) -> i32
      "llvm.call"(%0) {callee = @exit} : (i32) -> ()
      "func.call"(%1) {callee = @exit} : (i32) -> ()
      "scf.yield"() : () -> ()
    }, {
    }) : (i1) -> ()
    %14 = "llvm.getelementptr"(<<UNKNOWN SSA VALUE>>) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %15 = "llvm.load"(%14) : (!llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %16 = "llvm.sext"(%arg1) : (i32) -> i64
    %17 = "arith.index_cast"(<<UNKNOWN SSA VALUE>>) : (i32) -> index
    %18 = "arith.index_cast"(%17) : (index) -> i64
    %19 = "llvm.getelementptr"(%15, %18) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %20 = "llvm.getelementptr"(%19) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
    %21 = "llvm.getelementptr"(%20) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %22 = "llvm.getelementptr"(%19) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %23 = "llvm.load"(%22) : (!llvm.ptr<i32>) -> i32
    %24 = "llvm.add"(%23, %0) : (i32, i32) -> i32
    %25 = "arith.addi"(%23, %1) : (i32, i32) -> i32
    "llvm.store"(%25, %22) : (i32, !llvm.ptr<i32>) -> ()
    %26 = "llvm.sext"(%23) : (i32) -> i64
    %27 = "arith.index_cast"(%23) : (i32) -> index
    %28 = "arith.index_cast"(%27) : (index) -> i64
    %29 = "llvm.getelementptr"(%21, %28) {structIndices = dense<-2147483648> : tensor<1xi32>} : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %30 = "llvm.call"(%arg2, %arg3) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
    %31 = "func.call"(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>>) {callee = @new_graph_node} : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
    "llvm.store"(%31, %29) : (!llvm.ptr<struct<(f64, i32)>>, !llvm.ptr<ptr<struct<(f64, i32)>>>) -> ()
    "llvm.return"() : () -> ()
    "func.return"() : () -> ()
  }) {function_type = !llvm.func<void (ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()
  "func.func"() ({
  }) {function_type = (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> (), llvm.linkage = #llvm.linkage<external>, sym_name = "add_edge"} : () -> ()
  "llvm.func"() ({
  }) {function_type = !llvm.func<void (i32)>, linkage = #llvm.linkage<external>, sym_name = "exit", sym_visibility = "private"} : () -> ()
  "func.func"() ({
  }) {function_type = (i32) -> (), llvm.linkage = #llvm.linkage<external>, sym_name = "exit", sym_visibility = "private"} : () -> ()
  "llvm.func"() ({
  ^bb0(%arg0: i32, %arg1: f64):
    %0 = "arith.constant"() {value = 16 : i64} : () -> i64
    %1 = "llvm.call"(%0) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
    %2 = "llvm.bitcast"(%1) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(f64, i32)>>
    %3 = "llvm.getelementptr"(%2) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<i32>
    "llvm.store"(<<UNKNOWN SSA VALUE>>, %3) : (i32, !llvm.ptr<i32>) -> ()
    %4 = "llvm.getelementptr"(%2) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<f64>
    "llvm.store"(<<UNKNOWN SSA VALUE>>, %4) : (f64, !llvm.ptr<f64>) -> ()
    "func.return"(%2) : (!llvm.ptr<struct<(f64, i32)>>) -> ()
  }) {function_type = !llvm.func<ptr<struct<(f64, i32)>> (i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "new_graph_node"} : () -> ()
  "func.func"() ({
  }) {function_type = (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>, llvm.linkage = #llvm.linkage<external>, sym_name = "new_graph_node"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'arith.constant'(0x7fd610b087b0) {
  %0 = "arith.constant"() {value = 16 : i64} : () -> i64

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.constant'(0x7fd60ff0f610)
    ** Replace : 'arith.constant'(0x7fd610b087b0)
"(anonymous namespace)::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x7fd60ff0f610) {
      %0 = "llvm.mlir.constant"() {value = 16 : i64} : () -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'func.return' op expects parent op 'func.func'
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: i32, %arg1: f64):
  %0 = "llvm.mlir.constant"() {value = 16 : i64} : () -> i64
  %1 = "arith.constant"() {value = 16 : i64} : () -> i64
  %2 = "llvm.call"(%1) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %3 = "llvm.bitcast"(%2) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(f64, i32)>>
  %4 = "llvm.getelementptr"(%3) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<i32>
  "llvm.store"(<<UNKNOWN SSA VALUE>>, %4) : (i32, !llvm.ptr<i32>) -> ()
  %5 = "llvm.getelementptr"(%3) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<f64>
  "llvm.store"(<<UNKNOWN SSA VALUE>>, %5) : (f64, !llvm.ptr<f64>) -> ()
  "func.return"(%3) : (!llvm.ptr<struct<(f64, i32)>>) -> ()
}) {function_type = !llvm.func<ptr<struct<(f64, i32)>> (i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "new_graph_node"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x7fd610b08840) {
  %2 = "llvm.call"(%1) {callee = @malloc} : (i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x7fd610b08e80) {
  %3 = "llvm.bitcast"(%2) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(f64, i32)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fd610b08f50) {
  %4 = "llvm.getelementptr"(%3) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<i32>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x7fd610b08ff0) {
  "llvm.store"(<<UNKNOWN SSA VALUE>>, %4) : (i32, !llvm.ptr<i32>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x7fd610b091c0) {
  %5 = "llvm.getelementptr"(%3) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<f64>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x7fd610b09260) {
  "llvm.store"(<<UNKNOWN SSA VALUE>>, %5) : (f64, !llvm.ptr<f64>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func.return'(0x7fd610b09310) {
  "func.return"(%3) : (!llvm.ptr<struct<(f64, i32)>>) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func.return -> ()' {
Trying to match "(anonymous namespace)::ReturnOpLowering"
    ** Insert  : 'llvm.return'(0x7fd610c05710)
    ** Replace : 'func.return'(0x7fd610b09310)
"(anonymous namespace)::ReturnOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.return'(0x7fd610c05710) {
      "llvm.return"(%3) : (!llvm.ptr<struct<(f64, i32)>>) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
mlir-asm-printer: Verifying operation: llvm.func
'llvm.return' op must be the last operation in the parent block
mlir-asm-printer: 'llvm.func' failed to verify and will be printed in generic form
"llvm.func"() ({
^bb0(%arg0: i32, %arg1: f64):
  %0 = "llvm.mlir.constant"() {value = 16 : i64} : () -> i64
  %1 = "arith.constant"() {value = 16 : i64} : () -> i64
  %2 = "llvm.call"(%1) {callee = @malloc} : (i64) -> !llvm.ptr<i8>
  %3 = "llvm.bitcast"(%2) : (!llvm.ptr<i8>) -> !llvm.ptr<struct<(f64, i32)>>
  %4 = "llvm.getelementptr"(%3) {structIndices = dense<[0, 1]> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<i32>
  "llvm.store"(<<UNKNOWN SSA VALUE>>, %4) : (i32, !llvm.ptr<i32>) -> ()
  %5 = "llvm.getelementptr"(%3) {structIndices = dense<0> : tensor<2xi32>} : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<f64>
  "llvm.store"(<<UNKNOWN SSA VALUE>>, %5) : (f64, !llvm.ptr<f64>) -> ()
  "llvm.return"(%3) : (!llvm.ptr<struct<(f64, i32)>>) -> ()
  "func.return"(%3) : (!llvm.ptr<struct<(f64, i32)>>) -> ()
}) {function_type = !llvm.func<ptr<struct<(f64, i32)>> (i32, f64)>, linkage = #llvm.linkage<external>, sym_name = "new_graph_node"} : () -> ()


} -> SUCCESS
//===-------------------------------------------===//
** Insert  : 'builtin.unrealized_conversion_cast'(0x7fd610820630)
** Insert  : 'builtin.unrealized_conversion_cast'(0x7fd60ff0fa00)
** Insert  : 'builtin.unrealized_conversion_cast'(0x7fd6108206b0)
** Insert  : 'builtin.unrealized_conversion_cast'(0x7fd6108207b0)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::PreservedAnalyses::AllAnalysesType)
mlir-asm-printer: Verifying operation: builtin.module
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>>, llvm.data_layout = "", llvm.target_triple = "x86_64-unknown-linux-gnu", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  llvm.func @printf(!llvm.ptr<i8>, ...) -> i32
  llvm.mlir.global internal constant @str0("Too many neighbours for node %d\0A\00") {addr_space = 0 : i32}
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @main(%arg0: i32, %arg1: !llvm.ptr<ptr<i8>>) -> i32 {
    %0 = llvm.mlir.constant(2000000 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %2 = llvm.mlir.constant(0 : index) : i64
    %3 = builtin.unrealized_conversion_cast %2 : i64 to index
    %4 = llvm.mlir.constant(1 : index) : i64
    %5 = builtin.unrealized_conversion_cast %4 : i64 to index
    %6 = llvm.mlir.constant(16 : i64) : i64
    %7 = llvm.mlir.constant(272000000 : i64) : i64
    %8 = llvm.mlir.constant(5.000000e-01 : f64) : f64
    %9 = llvm.mlir.constant(1 : i32) : i32
    %10 = llvm.mlir.constant(0 : i32) : i32
    %11 = llvm.call @malloc(%6) : (i64) -> !llvm.ptr<i8>
    %12 = llvm.bitcast %11 : !llvm.ptr<i8> to !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>
    %13 = llvm.getelementptr %12[0, 0] : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %14 = llvm.call @malloc(%7) : (i64) -> !llvm.ptr<i8>
    %15 = llvm.bitcast %14 : !llvm.ptr<i8> to !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    llvm.store %15, %13 : !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    scf.for %arg2 = %3 to %1 step %5 {
      %16 = builtin.unrealized_conversion_cast %arg2 : index to i64
      %17 = llvm.getelementptr %12[0, 0] : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
      %18 = llvm.load %17 : !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
      %19 = llvm.getelementptr %18[%16] : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
      %20 = llvm.getelementptr %19[0, 1] : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
      llvm.store %10, %20 : !llvm.ptr<i32>
    }
    llvm.call @add_edge(%12, %10, %9, %8) : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, i32, i32, f64) -> ()
    llvm.return %10 : i32
  }
  llvm.func @add_edge(%arg0: !llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>, %arg1: i32, %arg2: i32, %arg3: f64) {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.mlir.constant(16 : i32) : i32
    %2 = llvm.getelementptr %arg0[0, 0] : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %3 = llvm.load %2 : !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %4 = llvm.sext %arg1 : i32 to i64
    %5 = llvm.getelementptr %3[%4] : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %6 = llvm.getelementptr %5[0, 1] : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %7 = llvm.load %6 : !llvm.ptr<i32>
    %8 = llvm.icmp "sge" %7, %1 : i32
    scf.if %8 {
      %21 = llvm.mlir.addressof @str0 : !llvm.ptr<array<33 x i8>>
      %22 = llvm.getelementptr %21[0, 0] : (!llvm.ptr<array<33 x i8>>) -> !llvm.ptr<i8>
      %23 = llvm.call @printf(%22, %arg1) : (!llvm.ptr<i8>, i32) -> i32
      llvm.call @exit(%0) : (i32) -> ()
    }
    %9 = llvm.getelementptr %arg0[0, 0] : (!llvm.ptr<struct<(ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i32)>>) -> !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %10 = llvm.load %9 : !llvm.ptr<ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>>
    %11 = llvm.sext %arg1 : i32 to i64
    %12 = llvm.getelementptr %10[%11] : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>, i64) -> !llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>
    %13 = llvm.getelementptr %12[0, 0] : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>
    %14 = llvm.getelementptr %13[0, 0] : (!llvm.ptr<array<16 x ptr<struct<(f64, i32)>>>>) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %15 = llvm.getelementptr %12[0, 1] : (!llvm.ptr<struct<(array<16 x ptr<struct<(f64, i32)>>>, i32)>>) -> !llvm.ptr<i32>
    %16 = llvm.load %15 : !llvm.ptr<i32>
    %17 = llvm.add %16, %0  : i32
    llvm.store %17, %15 : !llvm.ptr<i32>
    %18 = llvm.sext %16 : i32 to i64
    %19 = llvm.getelementptr %14[%18] : (!llvm.ptr<ptr<struct<(f64, i32)>>>, i64) -> !llvm.ptr<ptr<struct<(f64, i32)>>>
    %20 = llvm.call @new_graph_node(%arg2, %arg3) : (i32, f64) -> !llvm.ptr<struct<(f64, i32)>>
    llvm.store %20, %19 : !llvm.ptr<ptr<struct<(f64, i32)>>>
    llvm.return
  }
  llvm.func @exit(i32) attributes {sym_visibility = "private"}
  llvm.func @new_graph_node(%arg0: i32, %arg1: f64) -> !llvm.ptr<struct<(f64, i32)>> {
    %0 = llvm.mlir.constant(16 : i64) : i64
    %1 = llvm.call @malloc(%0) : (i64) -> !llvm.ptr<i8>
    %2 = llvm.bitcast %1 : !llvm.ptr<i8> to !llvm.ptr<struct<(f64, i32)>>
    %3 = llvm.getelementptr %2[0, 1] : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<i32>
    llvm.store %arg0, %3 : !llvm.ptr<i32>
    %4 = llvm.getelementptr %2[0, 0] : (!llvm.ptr<struct<(f64, i32)>>) -> !llvm.ptr<f64>
    llvm.store %arg1, %4 : !llvm.ptr<f64>
    llvm.return %2 : !llvm.ptr<struct<(f64, i32)>>
  }
}

